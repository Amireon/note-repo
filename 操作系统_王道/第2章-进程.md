## 2.1 进程
### 1.进程概述

引入多道程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了进程进程实体的概念

操作内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢？

系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码放位置）

**程序段、数据段、PCB三部分组成了进程实体（进程映像）**。一般情况下，我们把进程实体就简称为进程

例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

**PCB是进程存在的唯一标志！**

**1.进程的组成**
`进程 = PCB + 程序段 + 数据段`
- PCB：进程的管理者（操作系统）所需的数据都在PCB中
- 程序段+数据段：程序本身运行所需的数据

PCB的存储内容
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131645632.png)

**2.进程的组织**
- `链接方式`：按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针
- `索引方式`：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针

**3.进程的特征**
- `动态性`：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征
- `并发性`：内存中有多个进程实体，各进程可并发执行
- `独立性`：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- `异步性`：各进程按各自独立的、不可预知的速度向前推进；操作系统要提供“进程同步机制”来解决异步问题
- `结构性`：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131657055.png)

### 2.进程的状态与转换
#### 1.进程的状态
进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态

**1.进程的三种基本状态**
- `运行态(Running)`：占有CPU，并在CPU上运行
> 单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进桂处于运行态
- `就绪态(Ready)`：已经具备运行条件，但由于没有空闲CPU，所以暂时不能运行
> 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
- `阻塞态(Waiting/Blocked)`：又称等待态，因等待某一事件暂时不能运行
> 如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务

#### 2.进程状态的转换
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710658.png)

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710911.png)

### 3.进程控制
`进程控制`：实现进程状态的转换
进程控制使用**原语实现**
- 原语用关/开中断实现
- 原语是一种特殊的程序
- 原语的执行必须一气呵成，不可中断
- 相关原语：创建、终止、阻塞、唤醒、切换；阻塞和唤醒成对出现

学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：
1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境
	a.所有的进程控制原语一定都会修改进程状态标志
	b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境
	c.某进程开始运行前必然要恢复期运行环境
1. 将PCB插入合适的队列
2. 分配/回收资源

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141228084.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141229710.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230611.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230688.png)

### 4.进程通信
- 进程通信就是指进程之间的信息交换。
- 进程是分配系统资源的单位（包括内存地址空间），因此**各进程拥有的内存地址空间相互独立**
- 一个进程不能直接访问另一个进程的地址空间
但是进程之间的信息交换又是必须实现的为了保证进程间的安全通信，操作系统提供了一些方法

进程通信的三种方式：
- `共享存储`：基于数据结构的共享，基于存储区的共享
- `消息传递`：直接通信方式，间接通信方式
- `管道通信`：
	- 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道；
	- 各进程互斥地访问管道；
	- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read(系统调用将被阻塞
	- 如果管道没写满，则不允许读；如果管道没读空，则不允许写
	- 读进程只能有一个

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141245238.png)



## 2.2 线程
### 1.线程概述
- 可以把线程理解为“轻量级进程”。
- 线程是一个基本的CPU执行单元也是程序执行流的最小单位
- 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件
- 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。

**1.引入线程带来的变化**
- `资源分配、调度`：进程机制中，进程是资源分配的基本单位；引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- `并发性`: 传统进程机制中，只能进程间并发; 引入线程后，各线程间也能并发，提升了并发度
- `系统开销`：传统的进程间并发,需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

**2.线程的属性**
- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPu
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小


**2.线程的实现方式**
**用户级线程(User-Level Thread,ULT)**
- 用户级线程由应用程序通过线程库实现
- 所有的线程管理工作都由应用程序负责（包括线程切换）
- 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
- 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明
- 可以这样理解，“用户级线程”就是“从用户视角看能看到的线程

**内核级线程(Kernel-Level Thread, KLT)**
- 内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
- 可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程

操作系统只看见内核级线程，因此只有内核级线程才是处理机分配的单位

**3.多线程模型**
多对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141319114.png)

一对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141320339.png)

多对多
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141321977.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141322947.png)


### 2.处理机调度
处理机调度：按照某种算法选择一个进程将处理机分配给它
三层调度的联系、对比
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141359904.png)


### 3.进程调度
进程调度(低级调度)：从就绪队列中选择一个进程为其分配处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141406871.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141414571.png)

### 4.调度算法的评价指标

| 指标         | 含义                                                   | 公式                                           |
| ------------ | ------------------------------------------------------ | ---------------------------------------------- |
| CPU利用率    | CPU忙碌的时间占总时间的比例                            | CPU利用率 = CPU忙碌的时间 / 总时间             |
| 系统吞吐量   | 单位时间内完成作业的总数                               | 系统吞吐量 = 完成的作业总数 / 总时间           |
| 周转时间     | 指从作业提交给系统开始，到作业完成为止的这段时间间隔。 | 作业周转时间 = 作业完成时间 - 作业提交时间     |
| 带权周转时间 | 考虑进程实际运行时间                                   | 带权周转时间 = 作业周转时间 / 作业实际运行时间 |
| 等待时间     | 指进程/作业处于等待处理机状态时间之和                  |                                                |
| 响应时间     | 从用户提交请求到首次产生响应所用的时间                 |                                                |

**周转时间**包括四个部分：
- 作业在外存后备队列上等待作业调度（高级调度）的时间
- 进程在就绪队列上等待进程调度（低级调度）的时间
- 进程在CPU上执行的时间
- 进程等待I/0操作完成的时间
后三项在一个作业的整个处理过程中，可能发生多次

**带权周转时间**：
- 对于周转时间相同的两个作业，实际运行时间长的作业在相司时间内被服务的时间更多，带权周转时间更小，用户满意度更高
- 对于实际运行时间相司的两个作业，周转时间短的带权周转时间更小，用户满意度更高
- 带权周转时间必然 ≥ 1
- 带权周转时间与周转时间都是越小越好

**等待时间**：
- 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的、所以不计入等待时间。
- 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- 一个作业总共需要被CPU服务多久，被I/0设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141432245.png)

### 5.调度算法分析
先来先服务(FCFS, First Come First Serve)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141629766.png)

短作业优先(SJF, Shortest Job First)
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141701505.png)

高响应比优先(HRRN, Highest Response Ratio Next)
非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141706851.png)

| 算法    | 是否抢占                                       | 优点                         | 缺点                                   | 考虑点             | 是否饥饿 |
| ------- | ---------------------------------------------- | ---------------------------- | -------------------------------------- | ------------------ | -------- |
| FSFC    | 非抢占                                         | 公平；实现简单               | 对短作业不利                           | 等待时间           | 不会     |
| SJF/SPF | 默认非抢占式，抢占式的最短剩余时间优先算法SRTN | “最短”平均等待时间/周转时间  | 对长作业不利；难以完成真正的短作业优先 | 运行时间           | 会       |
| HRRN    | 非抢占式                                       | 上述两种算法的权衡，综合考虑 |                                        | 等待时间和运行时间 | 不会         |

>- 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，对于用户来说，交互性很糟糕。
>- 因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。
>- 而适合用于交互式系统的调度算法将在下个小节介绍!…

### 6.调度算法:交互式系统
时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法

时间片轮转算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141733685.png)

优先级调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141749370.png)

多级反馈队列调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141755356.png)

| 算法         | 是否抢占 | 优点                       | 缺点                         | 是否饥饿 | 补充                                  |     |
| ------------ | -------- | -------------------------- | ---------------------------- | -------- | ------------------------------------- | --- |
| 时间轮转     | 抢占式   | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级 | 不会     | 时间片太大或太小的影响                |     |
| 优先级调度   | 都有     | 区分优先级，适用于实时系统 | 可能导致饥饿                 | 会       | 动态/静态优先级，个进程如何设置优先级 |     |
| 多级反馈队列 | 抢占式   | 平衡                       | 可能饥饿                     | 会       |                                       |     |

>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
>而这几种算法恰好也能较好地满足交互式系统的需求,比如UNIX使用的就是多级反馈队列调度算法


## 2.3 进程同步与互斥
**1.什么是进程同步**
读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的如何解决这种异步问题，就是“进程同步”所讨论的内容。

**同步亦称直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

**2.什么是进程互斥**
我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。

**互斥，亦称间接制约关系**。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后另一个进程才能去访问临界资源

对临界资源的互斥访问，可以在逻辑上分为如下四部分：

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141812090.png)

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则
- `空闲让进`: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区:
- `忙则等待`: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待
- `有限等待`: 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
- `让权等待`: 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

### 1.进程互斥的软件实现算法



