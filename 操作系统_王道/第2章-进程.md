## 2.1 进程
### 1.进程概述

引入多道程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了进程进程实体的概念

操作内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢？

系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码放位置）

**程序段、数据段、PCB三部分组成了进程实体（进程映像）**。一般情况下，我们把进程实体就简称为进程

例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

**PCB是进程存在的唯一标志！**

**1.进程的组成**
`进程 = PCB + 程序段 + 数据段`
- PCB：进程的管理者（操作系统）所需的数据都在PCB中
- 程序段+数据段：程序本身运行所需的数据

PCB的存储内容
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131645632.png)

**2.进程的组织**
- `链接方式`：按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针
- `索引方式`：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针

**3.进程的特征**
- `动态性`：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征
- `并发性`：内存中有多个进程实体，各进程可并发执行
- `独立性`：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- `异步性`：各进程按各自独立的、不可预知的速度向前推进；操作系统要提供“进程同步机制”来解决异步问题
- `结构性`：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131657055.png)

### 2.进程的状态与转换
#### 1.进程的状态
进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态

**1.进程的三种基本状态**
- `运行态(Running)`：占有CPU，并在CPU上运行
> 单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进桂处于运行态
- `就绪态(Ready)`：已经具备运行条件，但由于没有空闲CPU，所以暂时不能运行
> 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
- `阻塞态(Waiting/Blocked)`：又称等待态，因等待某一事件暂时不能运行
> 如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务

#### 2.进程状态的转换
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710658.png)

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710911.png)

### 3.进程控制
`进程控制`：实现进程状态的转换
进程控制使用**原语实现**
- 原语用关/开中断实现
- 原语是一种特殊的程序
- 原语的执行必须一气呵成，不可中断
- 相关原语：创建、终止、阻塞、唤醒、切换；阻塞和唤醒成对出现

学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：
1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境
	a.所有的进程控制原语一定都会修改进程状态标志
	b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境
	c.某进程开始运行前必然要恢复期运行环境
1. 将PCB插入合适的队列
2. 分配/回收资源

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141228084.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141229710.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230611.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230688.png)

### 4.进程通信
- 进程通信就是指进程之间的信息交换。
- 进程是分配系统资源的单位（包括内存地址空间），因此**各进程拥有的内存地址空间相互独立**
- 一个进程不能直接访问另一个进程的地址空间
但是进程之间的信息交换又是必须实现的为了保证进程间的安全通信，操作系统提供了一些方法

进程通信的三种方式：
- `共享存储`：基于数据结构的共享，基于存储区的共享
- `消息传递`：直接通信方式，间接通信方式
- `管道通信`：
	- 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道；
	- 各进程互斥地访问管道；
	- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read(系统调用将被阻塞
	- 如果管道没写满，则不允许读；如果管道没读空，则不允许写
	- 读进程只能有一个

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141245238.png)



## 2.2 线程
### 1.线程概述
- 可以把线程理解为“轻量级进程”。
- 线程是一个基本的CPU执行单元也是程序执行流的最小单位
- 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件
- 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。

**1.引入线程带来的变化**
- `资源分配、调度`：进程机制中，进程是资源分配的基本单位；引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- `并发性`: 传统进程机制中，只能进程间并发; 引入线程后，各线程间也能并发，提升了并发度
- `系统开销`：传统的进程间并发,需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

**2.线程的属性**
- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPu
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小


**2.线程的实现方式**
**用户级线程(User-Level Thread,ULT)**
- 用户级线程由应用程序通过线程库实现
- 所有的线程管理工作都由应用程序负责（包括线程切换）
- 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
- 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明
- 可以这样理解，“用户级线程”就是“从用户视角看能看到的线程

**内核级线程(Kernel-Level Thread, KLT)**
- 内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
- 可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程

操作系统只看见内核级线程，因此只有内核级线程才是处理机分配的单位

**3.多线程模型**
多对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141319114.png)

一对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141320339.png)

多对多
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141321977.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141322947.png)


### 2.处理机调度
处理机调度：按照某种算法选择一个进程将处理机分配给它
三层调度的联系、对比
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141359904.png)


### 3.进程调度
进程调度(低级调度)：从就绪队列中选择一个进程为其分配处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141406871.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141414571.png)

### 4.调度算法的评价指标

| 指标         | 含义                                                   | 公式                                           |
| ------------ | ------------------------------------------------------ | ---------------------------------------------- |
| CPU利用率    | CPU忙碌的时间占总时间的比例                            | CPU利用率 = CPU忙碌的时间 / 总时间             |
| 系统吞吐量   | 单位时间内完成作业的总数                               | 系统吞吐量 = 完成的作业总数 / 总时间           |
| 周转时间     | 指从作业提交给系统开始，到作业完成为止的这段时间间隔。 | 作业周转时间 = 作业完成时间 - 作业提交时间     |
| 带权周转时间 | 考虑进程实际运行时间                                   | 带权周转时间 = 作业周转时间 / 作业实际运行时间 |
| 等待时间     | 指进程/作业处于等待处理机状态时间之和                  |                                                |
| 响应时间     | 从用户提交请求到首次产生响应所用的时间                 |                                                |

**周转时间**包括四个部分：
- 作业在外存后备队列上等待作业调度（高级调度）的时间
- 进程在就绪队列上等待进程调度（低级调度）的时间
- 进程在CPU上执行的时间
- 进程等待I/0操作完成的时间
后三项在一个作业的整个处理过程中，可能发生多次

**带权周转时间**：
- 对于周转时间相同的两个作业，实际运行时间长的作业在相司时间内被服务的时间更多，带权周转时间更小，用户满意度更高
- 对于实际运行时间相司的两个作业，周转时间短的带权周转时间更小，用户满意度更高
- 带权周转时间必然 ≥ 1
- 带权周转时间与周转时间都是越小越好

**等待时间**：
- 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的、所以不计入等待时间。
- 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- 一个作业总共需要被CPU服务多久，被I/0设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141432245.png)

### 5.调度算法分析
先来先服务(FCFS, First Come First Serve)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141629766.png)

短作业优先(SJF, Shortest Job First)
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141701505.png)

高响应比优先(HRRN, Highest Response Ratio Next)
非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141706851.png)

| 算法    | 是否抢占                                       | 优点                         | 缺点                                   | 考虑点             | 是否饥饿 |
| ------- | ---------------------------------------------- | ---------------------------- | -------------------------------------- | ------------------ | -------- |
| FSFC    | 非抢占                                         | 公平；实现简单               | 对短作业不利                           | 等待时间           | 不会     |
| SJF/SPF | 默认非抢占式，抢占式的最短剩余时间优先算法SRTN | “最短”平均等待时间/周转时间  | 对长作业不利；难以完成真正的短作业优先 | 运行时间           | 会       |
| HRRN    | 非抢占式                                       | 上述两种算法的权衡，综合考虑 |                                        | 等待时间和运行时间 | 不会         |

>- 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，对于用户来说，交互性很糟糕。
>- 因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。
>- 而适合用于交互式系统的调度算法将在下个小节介绍!…

### 6.调度算法:交互式系统
时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法

时间片轮转算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141733685.png)

优先级调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141749370.png)

多级反馈队列调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141755356.png)

| 算法         | 是否抢占 | 优点                       | 缺点                         | 是否饥饿 | 补充                                  |     |
| ------------ | -------- | -------------------------- | ---------------------------- | -------- | ------------------------------------- | --- |
| 时间轮转     | 抢占式   | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级 | 不会     | 时间片太大或太小的影响                |     |
| 优先级调度   | 都有     | 区分优先级，适用于实时系统 | 可能导致饥饿                 | 会       | 动态/静态优先级，个进程如何设置优先级 |     |
| 多级反馈队列 | 抢占式   | 平衡                       | 可能饥饿                     | 会       |                                       |     |

>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
>而这几种算法恰好也能较好地满足交互式系统的需求,比如UNIX使用的就是多级反馈队列调度算法


## 2.3 进程同步与互斥
**1.什么是进程同步**
读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的如何解决这种异步问题，就是“进程同步”所讨论的内容。

**同步亦称直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

**2.什么是进程互斥**
我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。

**互斥，亦称间接制约关系**。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后另一个进程才能去访问临界资源

对临界资源的互斥访问，可以在逻辑上分为如下四部分：

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141812090.png)

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则
- `空闲让进`: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区:
- `忙则等待`: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待
- `有限等待`: 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
- `让权等待`: 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

### 1.进程互斥的软件实现算法
单标志法、双标志先检查、双标志后检查、Peterson算法

> - 理解各个算法的思想、原理
> - 结合“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区的行为
> - 分析各算法存在的缺陷

**1.单标志法**
- 算法思想：两个进程在访问完临界区后会把使用临界区的权限交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予
- 该算法可以实现**同一时刻最多只允许一个进程访问临界区**
- 问题：如果初始进程长时间不访问临界区，那么临界区将处于空闲状态，违背“空闲让进”原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150941438.png)

- turn 的初值为0，那么刚开始时只允许 P0 进入临界区（P1会被卡在 while 循环，直至 P1 的时间片用完，调度 P0 上处理机运行）
- P0 使用完临界区后将 turn 的值更改为1，此后 P1 才能使用临界区

 **2.双标志先检查法**
 - 算法思想：设置一个布尔型数组`flag[]`，数组中各个元素用来标记各进程想进入临界区的意愿，比如`flag[0] = ture`意味着0号进程PO现在想要进入临界区。
 - 每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为true，之后开始访问临界区
 - 问题：并发性，进程可能同时访问临界区，违背“忙则等待”原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150951045.png)

若按照 152..48 的顺序执行，PO 和 P1 将会同时访问临界区。
原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。

**3.双标志后检查法**
- 算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查’的方法，来避免上述问题
- 问题：并发性，死锁，违背“空闲让进”和“有限等待”原则，让各进程都长期无法访问临界区

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150956202.png)

若按照 152..48 的顺序执行，PO 和 P1 都将会无法访问临界区。
因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象

**4.Peterson算法**
- 算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到，如果双方都争着想进入临界区，那可以让进程主动让对方先使用临界区
- 问题：Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、则等待、有限等待三个原则，但是依然未遵循让权等待的原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151000794.png)

- 两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。
- 我们可以推理验证在 Peterson 算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况: 123678... 或 1623 ...

实心进程互斥的软件方法的四种算法的比较
| 算法           | 思想                                                        | 问题                                    |
| -------------- | ----------------------------------------------------------- | --------------------------------------- |
| 单标志法       | 在进入区只"检查"，不"上锁";在退出区把临界区使用权转交       | 不遵循"空闲让进"原则                    |
| 双标志先监察法 | 在进入区先"检查"后"上锁", 退出区"解锁"                      | 不遵循"忙则等待"原则                    |
| 双标志后检查法 | 在进入区先"上锁"后"检查", 退出区"解锁"                      | 不遵循"空闲让进,有限等待"原则，可能饥饿 |
| Peterson 算法  | 在进入区"主动争取-主动谦让-检查对方是否想使用,己方是否谦让" | 不遵循"让权等待"原则，会导致"忙等"                                        |

### 2.进程互斥的硬件实现算法
> 中断屏蔽方法、TestAndSet(TS指令/TSL指令)，Swap指令(XCHG指令)

**1.中断屏蔽方法**
- 思路：利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况
- 优点：简单高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151015112.png)

**2.TestAndSet指令**
- 简称 TS指令，也有称 TestAndSetLock指令，或 TSL指令
- 思路：TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
- 相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作
- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”
 
以下是用C语言描述的逻辑
```c
//布尔型共享变量 lock 表示当前临界区是否被加锁
//true 表示已加锁,false 表示未加锁
bool TestAndSet（bool *lock){
	bool oLd;
	old = *lock； //old 用来存放 lock 原来的值
	*lock = true； //无论之前是否已加锁，都将 lock 设为 true
	return oLd；  //返回 lock 原来的值
}
```

以下是使用 TSL指令 实现互斥的算法逻辑
```c
while（TestAndSet(&lock)); //"上锁"并“检查
临界区代码段...
lock = false;               //“解锁”
剩余区代码段...
```

- 若 lock 初始值是false，则 TSL返回的 old 值为false，while循环条件不满足，直接跳过循环，进入临界区。
- 若 lock 初始值是true，则执行 TSL 后 old 值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”

**3.Swap指令**
- 有的地方也叫Exchange 指令，或简称 XCHG指令。
- Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
 
 
以下是用C语言描述的逻辑
```c
//Swap指令的作用是交换两个变量的值
Swap(bool *a*, bool *b){
	bool temp:
	temp = *a；
	*a = *b;
	*b = temp;
}
```

以下用Swap指令实现互斥的算法逻辑
```c
//lock泰示当前临界区是否发加
bool old = true;
while(old = true)
	Swap(&Lock, &old);
临界区代码段...
lock = false;
剩余区代码段...
```

逻辑上来看Swap和 TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old变量上），再将上锁标记lock设置为 true，最后检查 old，如果 old为 false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151046506.png)


### 3.信号量机制
- 用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。
- 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量
- 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。
- 一对原语：wait(S）原语和signal(S）原语，可以把原语理解为我们自己写的函数，函数名分别为 wai和 signal，括号里的信号量S其实就是函数调用时传入的一个参数
- wait、signal原语常简称为P、V操作（来自荷兰语 proberen和 verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S

**1.整形信号量**
- 用一个整数型的变量作为信号量，来表示系统中某种资源的数量
- 与普通整数变量的区别对信号量的操作只有三种: 初始化、P操作、V操作
- 问题：不满足“让权等待”原则，会导致“忙等”

```c
int S = 1; //初始化整型信号量S，表示当前系统中可用的打日机资源数
vo1d wait(int S）{    //wait原语，柏当于“进入区
	while(S<= 0);     //如果资源数不够，就一直循环等待
	S = S-1;          //如果资源数够，则占用一个资源
}
vo1d siqnal(int S）{//siqnaL原语,柏当于“退出区
	S = S+1;        //使用完资源后，在退出区释放资源
}
```

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151144606.png)

**2.记录性信号量**
- 整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。

记录型信号量的定义
```c
typedef struct {
	int value;         //剩余资源数
	struct process *L; //等待队列
} semaphore;
```

某进程需要使用资源时: 通过wait原语申请
如果剩余资源数不够使block原语使进程从运行态进入阳塞态，并把挂到信号量S的等待队列(阻塞队列)中

```c
void wait(semaphore S){
	S.value--:
	if(S.value < 0）{
		block(S.L):
	}
}
```

进程使用完资源后: 通过Siqnal原语释放
释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态

```c
void signal（semaphore S）{
	S.value++
	if(S.value <= 0){
		wakeup(S.L);
	}
}
```

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151243774.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151324533.png)


 小结
 ![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151325750.png)

### 4.信号量实现进程互斥和同步
**1.进程互斥**
1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）
2. 设置互斥信号量mutex，初值为1
3. 在临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

注：
- 对不同的临界资源需要设置不同的互斥信号量
- P、V操作必须成对出现。缺少P(mutex）就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒星

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151330951.png)

**2.进程同步**
进程同步：让各并发进程按要求有序地推进

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151333381.png)


用信号量机制实现进程同步：
1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码
2. 设置同步信号量S,初始为0
3. 在"前操作"之后执行V(S)
4. 在"后操作"之前执行P(S)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151337560.png)
 

`例题`：进程P1中有句代码S1，P2中有句代码S2...P3...P6 中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行
`解答`：其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作因此
1. 要为每一对前驱关系各设置一个同步变量
2. 在“前操作”之后对相应的同步变量执行V操作
3. 在“后操作”之前对相应的同步变量执行P操作

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151341810.png)


### 5.生产者-消费者问题
问题描述
- 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）
- 生产者、消费者共享一个初始为空、大小为n的缓冲区
- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待
- 只有缓冲区不空时，消费者才能取出产品，否则必须等待
- 缓冲区是临界资源，各进程必须互斥访问

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151348502.png)

**Q：如何通过信号量机制(P,V操作)实现生产者,消费者进程的这些功能?**
信号量机制可以实现互斥、同步、对一类系统资源的申请和释放

**PV操作题目分析步骤**
1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为, 同步信号量的红始值要看对应资源的初始值是名少）

关系分析：
- 缓冲区满时，生产者等待消费者取走产品：同步关系
- 缓冲区空时，消费者等待生产者放入产品：同步关系
- 各进程互斥访问：互斥关系

- 生产者每次要消耗(P）一个空闲缓冲区，并生产(V）一个产品
- 消费者每次要消耗(P）一个产品并释放一个空闲缓冲区(V)
- 往缓冲区放入/取走产品需要互斥

```c
semaphore mutex = 1; //互斥信号量, 实现对缓冲区的互斥访问
semaphore empty = n; //同步信号量, 表示空闲缓冲区的数量
semaphpre full = 0; //同步信号量, 表示产品数量, 即非空缓冲区的数量
```

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151435429.png)


### 6.多生产者-多消费者问题
**问题描述**
桌子上有一只城子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151447856.png)


**分析思路**：
1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步
2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值. (互斥信号量初值一般为1, 同步信号量的初始值要看对应资源的初始值是多少）

PV操作成对书写

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151452031.png)

```c
semaphpre mutex = 1;    //实现互斥访问盘子，缓冲区
semaphore mutex = 0;    //盘子中还有几个苹果
semaphore orange = 0;   //盘子中还有几个橘子
semaphore plate = 1;    //盘子中还可以放多少个水果
```

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151459771.png)

**Q1：不使用互斥信号量**

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151500060.png)

分析：
- 初始情况，儿子、女儿进程即使上处理机运行也会被阻塞。
- 如果初始是父亲进程先上处理机运行，那么父亲P(plate)，可以访问盘子 -> 母亲 P(plate)，阻塞等待盘子 -> 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）-> 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -> 母亲进程访问盘子（其他进程暂时都无法进入临界区）-> ...

原因: 本题中的缓冲区大小为1，在任何时刻，apple, orange, plate 三个同步信号量中最多只有一个为1，因此在任何时刻，只能有一个进程的P操作不会被阻塞，并顺利进入临界区

**Q2：缓冲区大小为2**
父亲P(plate)，可以访问盘子→母亲P(plate)，可以访问盘子→父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。于是就出现了两个进程同时访问缓冲区的，可能导致两个进程写入缓冲区的数据相互覆盖、

因此，如果缓冲区大小大干1,就必须专门设置一个互斥信号量mutex来保证石斥访问缓冲区。

**总结**：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析

建议：在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区
但需要注意的是，买现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151515080.png)

### 7.吸烟者问题
问题描述：
假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151549911.png)

- 吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。
- 值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注意体会我们是如何用一个整型变量i实现这个“轮流”过程的。
- 如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢
- 若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置。

### 8.读者-写者问题
**问题描述**
有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：
- 1) 允许多个读者可以同时对文件执行读操作；
- 2) 只允许一个写者往文件中写信息；
- 3) 任一写者在完成写操作之前不允许其他读者或写者工作；
- 4)写者执行写操作前，应让已有的读者和写者全部退出。

分析：
- 两类进程：写进程、读进程
- 互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题
- 写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作
- 读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。
- 如果所有读者进程在访问共享文件之前都执行 P(rw）操作，那么各个读进程之间也无法同时访问文件

**核心问题**：如何使各个读进程之间可以同时访问文件？
解答：
- P(rw）和V(rw)其实就是对共享文件的“加锁”和“解锁”。
- 既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读讲程“解锁”。
- 可以设置一个敕数变量count来记录当前有几个读讲程在访问文件，则当count>0时，阻塞写进程

```c
semaphore rw = 1; //用于实现对文件的互斥访问,表示当前是否有进程在访问共享文件
int count = 0;    //用于记录有几个读进程在访问文件
semaphore mutex = 1; //用于保证对count变量的互斥访问
```

写进程
```c
writer() {
	while(1) {
		P(rw);    //写进程加锁
		写操作...
		V(rw);    //解锁
	}
}
```

先不管如上的`mutex`变量，来分析下如下的这段读进程
```c
reader() {
	while(1){
		if(count == 0)  //第一个读进程加锁
			P(rw);
		count++;        //访问文件的读进程+1
		读进程操作...
		count--;        //访问文件的读进程-1
		if(count == 0)
			V(rw);      //最后一个读进程解锁
	}
}
```

`存在问题分析`: 若两个读进程并发执行，则两个读进程有可能先后执行P(rw)，从而使第二个读
进程阻塞的情况
`如何解决`：出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count 的访问是互斥的

对count添加访问保护后，修改的读进程:
```c
reader() {
	while(1){
		P(mutex);       //各进程互斥访问count
		if(count == 0)  //第一个读进程加锁
			P(rw);
		count++;        //访问文件的读进程+1
		V(mutex);
		读进程操作...
		P(mutex);
		count--;        //访问文件的读进程-1
		if(count == 0)
			V(rw);      //最后一个读进程解锁
		V(mutex);
	}
}
```

`存在的问题`: 只要有读进程还在读，上进程就要一直阻塞等待，可能“饿死”，这种算法中，读进程是优先的
`解决方案`: 添加互斥访问，实现写优先

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151635319.png)


**小结**
读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路
- 其核心思想在于设置了一个计数器count 用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。
- 对 count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量

绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决


### 9.哲学家进餐问题
**问题描述**：
一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根快于才可以开始进餐，当进餐完毕后，放下快子继续思考。
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151651978.png)

**问题分析**：
1. 关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系
2. 整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。
3. 信号量设置。定又互斥信号量数组`chopstick[5]={1,1,1,1,1}`用于实现对5个筷子的互斥访问。并对哲学家按 0~4 编号，哲学家i左边的筷子编号为i，右边的筷子编号为`(i + 1) % 5`

初始写法
```c
semaphore chopstick[5]= {1, 1, 1, 1, 1};

Pi() { //i号哲学家的操作
	while(1) {
		P(chopstick[i]);          //拿起左快子
		P(chopstick[(i+1) % 5]);  //右筷子
		吃饭....
		V(chopstick[i]);          //方下筷子
		V(chopstick[(i+1) % 5]);
		思考...
	}
}
```

`存在问题`: 如果5个哲学家并发，同时拿起了左侧的筷子，每位哲学家都在等待右侧的临界区, 则会导致死锁

`解决思路`:
1. 对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子
2. 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么二者只有一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况
3. 当哲学家身侧两只筷子都可用时，才拿起筷子

第二种方案的伪代码实现
```c
samphpore chopstick[5] = {1, 1, 1, 1, 1};

Pi() {
	while(1){
		if(i % 2 == 0) { //偶数
			P(chopstick[(i+1) % 5]);
			P(chopstick[i]);  
		} else {
			P(chopstick[i]);
			P(chopstick[(i+1) % 5]);
		}
		吃饭...
		V(chopstick[i]);
		V(chopstick[(i+1) % 5]);
		思考...
	}
}
```

第三种方案的伪代码实现
```c
samphore chopstick[5] = {1, 1, 1, 1, 1};
samhpore mutex = 1; //互斥地取筷子

P(i) {                       
	while(1) {
		P(mutex);
		P(chopstick[i]);          //拿左
		P(chopstick[(i+1) % 5]);  //拿右
		V(mutex);
		吃饭...
		V(chopstick[i]);
		V(chopstick[(i+1) % 5]);
		思考...
	}
}
```

此种方法并不能保证只有两边的便于都可用时才允许哲学家拿起筷子
更准确的说法应该是: 各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿锁子拿到一半时被阳塞，也不会有别的哲学家会继续尝试拿筷子。这样的话当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的快子了

**小结**
哲学家进餐问题的关键在于解决进程死锁
这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有
两个临界资源，因此就有“死锁”问题的隐患

如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁

### 10.管程
**1.为什么要引入管程**
- 信号量机制存在的问题：编写程序困难，易出错
- 能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢
- 1973年，Brinch Hansen首次在程序设计语言(Pascal中引入了“管程”成分一一 一种高级同步机制

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151707902.png)

**2.管程的定义和基本特征**
管程是一种特殊的软件模块，有这些部分组成:
1. 局部于管程的共享数据结构说明
2. 对该数据结构进行操作的一组过程
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字

管程的基本特征
1. 局部于管桂的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅充许一个进程在管程内执行某个内部过程

**拓展1:用管程解决生产者消费者问题**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151745180.png)


引入管程的目的无非就是要更方便地实现进程互斥和同步。
1. 需要在管程中定义共享数据（如生产者消费者问题的缓冲区）
2. 需要在管程中定义用于访问这些共享数据的“入口”一一其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品
3. 只有通过这些特定的“入口”才能访问共享数据
4. 管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的程序员不用关心
5. 可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒

程序员可以某种特殊的语法定义一个管程(比如:monitor ProducerConsumer ... end monitor)，
之后其他人就可以使用这个管程提供的特定入口实现进程同步/互斥了

**拓展2：Java中类似管程的机制**
在Java中，如果使用关键字`synchronized`来描述一个函数，那么这个函数同一时间段内只能被一个线程调用

```java
synchronized class Monitor {
	private Item buffer[] = new Item[N];
	private int count = 0;
	
	public synchronized void insert(Item item) {
		//每次只能有一个线程进入insert函数，
		//如果多个线程同时调用insert函数，
		//则后来者需要排队等待
	}
}
```


## 2.4 死锁
### 1.死锁概述

死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象
饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。
死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

| 比较项目 | 区别                                                                                                                                       |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| 死锁     | 死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少有两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态 |
| 饥饿     | 可能只有一个进程发生死循环。发生饥饿的进程既可能是阻塞态(如长期得不到需要的I/O设备)，也可能是就绪态(长期得不到处理机)                      |
| 死循环   |   可能只有一个进程发生死循环。死循环的进程可以上处理机运行（可以是运行态），只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁和饥我是官理者（操作系统）的问题，死循环是被管理者的问题    |                                                                                                                                     |


