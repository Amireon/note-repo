# 第2章 类加载子系统
## 1.内存结构概述
![简图](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161943803.png)

详细图
![详细_英文](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161942461.png)

中文版
![详细_中文](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161944508.png)

## 2.类加载器子系统
**类加载器子系统的作用：**
- 类加载器子系统负责从文件系统或者网络中加载 .class 文件，.class 文件在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
- **加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
![02_类加载器的作用](https://ypic.oss-cn-hangzhou.aliyuncs.com/20221018140320.png)

### ClassLoader
1. class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。
2. class file 加载到 JVM 中，被称为 DNA 元数据模版，放在方法区
3. 在 .class 文件 ---> JVM --->最终成为元数据模板，此过程就要一个运输工具（类加载器Class Loader）扮演一个快递员的角色
![类加载器ClassLoader角色](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210211947176.png)
## 3.类的加载过程
```java
public class HelloLoader {  
  
    public static void main(String[] args) {  
        System.out.println("谢谢ClassLoader加载我....");  
        System.out.println("你的大恩大德，我下辈子再报！");  
    }  
}
```

它的加载过程是怎么样的呢？
- 执行 main() 方法（静态方法）就需要先加载 main()方法所在类 HelloLoader
- 加载成功，则进行连接初始化等操作，完成后调用 HelloLoader 类中的静态方法 main()
- 加载失败，则抛出异常

![类加载过程](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212013447.png)
完整的流程图如下：

![类加载流程图](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212025665.png)

### 加载Loading
**加载：**
	1. 通过一个类的全限定名获取定义此类的二进制字节流
	2. 将这个字节类所代表的的静态存储结构转化为方法区的运行时数据结构
	3. <font color="red">在内存中生成代表此类的 java.lang.Class 对象</font>，作为方法区此类的各种数据的访问入口

**加载class文件的方式**
	1.  从本地系统中直接加载
	2.  通过网络获取，典型场景：Web Applet
	3.  从zip压缩包中读取，成为日后jar、war格式的基础
	4.  运行时计算生成，使用最多的是：动态代理技术
	5.  由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
	6.  从加密文件中获取，典型的防Class文件被反编译的保护措施

### 链接Linking
链接分为3个子阶段：验证（Verify) 、准备（Prepare）、解析（Resolve）
**1. 验证（Verify）**
	- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性
	- 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证

**举例**
使用 BinaryViewer 软件查看字节码文件，其开头均为 `CAFE BABE` ，如果出现不合法的字节码文件，那么验证将不通过。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212047257.png)

**2. 准备（Prepare）**
	- 为类变量（static变量）分配内存并且设置该类变量的默认初始值，零值
	- 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
	- 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

**举例**
变量a在准备阶段会赋初始值0，在初始化阶段被赋值为1
```java
public class HelloApp {  
    private static int a = 1;//prepare：a = 0 ---> initial : a = 1  
  
  
    public static void main(String[] args) {  
        System.out.println(a);  
    }  
}
```

**3.解析（Resolve）
- **将常量池内的符号引用转化为直接引用的过程**
- 解析操作往往会随着JVM在执行完初始化之后再执行
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等

>符号引用：反编译class文件后可以查看符号引用，下面带#的就是符号引用
>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码
>![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212055487.png)

### 初始化Initializing
类的初始化时机
1. 创建类的实例
2. 访问某个类或接口的静态变量，或对该静态变量赋值
3. 调用类的静态方法
4. 反射，比如`Class.forName("HelloWorld")`，HelloWorld.java
5. 初始化一个类的子类
6. Java 虚拟机启动时被标记为启动类的类
7. JDK7 开始提供的动态语言支持：`java.lang.invoke.MethodHandle` 实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化

初始化`<clinit>()`：
- 初始化阶段就是执行类构造器方法`<clint>()`的过程
- 此方法不需定义，由javac编译器自动收集类中的所有的类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- `<clint<>()` 不同与类的构造器，关联：构造器是虚拟机视角下的`init<>()`
- 若该类存在父类，JVM会保证子类的`<clinit>()` 执行前，父类的`<clint>()`已经执行完成
- 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁

举例:
**1. 有 static 变量**
查看如下代码的字节码，可以发现有一个`<clint>()` 方法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222104639.png)

```java
public class ClassInitTest {  
   private static int num = 1;  
  
   static{  
       num = 2;  
       number = 20;  
       System.out.println(num);  
       //System.out.println(number);//报错：非法的前向引用。  
   }  
  
   /**  
    * 1.linking之prepare: number = 0 --> initial: 20 --> 10  
    * 2.这里因为静态代码块出现在声明变量语句前面，
    *   所以之前被准备阶段为0的number变量会首先被初始化为20，
    *   再接着被初始化成10（这也是面试时常考的问题)  
    */  
   private static int number = 10;  
  
    public static void main(String[] args) {  
        System.out.println(ClassInitTest.num);//2  
        System.out.println(ClassInitTest.number);//10  
    }  
}
```

`<clint>`字节码
```class
 0 iconst_1  
 1 putstatic #3 <com/atguigu/java/ClassInitTest.num>  
 4 iconst_2  
 5 putstatic #3 <com/atguigu/java/ClassInitTest.num>  
 8 bipush 20	 //先赋20  
10 putstatic #5 <com/atguigu/java/ClassInitTest.number>  
13 getstatic #2 <java/lang/System.out>  
16 getstatic #3 <com/atguigu/java/ClassInitTest.num>  
19 invokevirtual #4 <java/io/PrintStream.println>  
22 bipush 10	//再赋10  
24 putstatic #5 <com/atguigu/java/ClassInitTest.number>  
27 return
```

**举例2：无static变量**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222114700.png)

添加 static 变量边产生 `<clinit>() `方法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222116997.png)

**例3.执行顺序**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222123687.png)

在构造器中：
- 先将类变量 a 赋值为10
- 在将局部变量赋值为20

**例4.父类的clinit<>()**
若该类存在父类，JVM会保证父类的`<clinit>()`方法在子类的`<clint<>()`方法执行前执行完毕
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222129850.png)

输出结果：2
如上代码的执行流程如下:
1) 首先执行 main() 方法，此时需要加载 ClinitSonTest 类
2) 获取 Son.B 静态变量，此时需要加载 Son 类
3) Son 类存在父类为 Father 类，此时先加载 Father 类，在执行 Son 类的加载

**例5.同步加锁**
虚拟机必须保证一个类的`<clinit>()` 方法在多线程模式下被同步加锁

如下代码：
```java
public class DeadThreadTest {  
    public static void main(String[] args) {  
        Runnable r = () -> {  
            System.out.println(Thread.currentThread().getName()
	             + "开始");  
            DeadThread dead = new DeadThread();  
            System.out.println(Thread.currentThread().getName() 
	            + "结束");  
        };  
  
        Thread t1 = new Thread(r,"线程1");  
        Thread t2 = new Thread(r,"线程2");  
  
        t1.start();  
        t2.start();  
    }  
}  
  
class DeadThread{  
    static{  
        if(true){  
            System.out.println(Thread.currentThread().getName() 
	            + "初始化当前类");  
            while(true){  
  
            }  
        }  
    }  
}
```

输出结果:
```text
线程2开始  
线程1开始  
线程2初始化当前类  
  
// 然后程序卡死了
```

分析程序卡住的原因：
1) 两个线程同时加载 DeadThread 类，而 DeadThread 类中的静态代码块中有死循环
2) 先加载 DeadThread 类的线程得到同步锁，接着进入静态代码中的死循环，另一个线程只能等待同步锁被释放
3) 因此无论哪个线程先执行 DeadThread 类的加载，另一个类都不会继续执行。一个类加载一次

## 4. 类加载器的分类
### 1.类加载器概述
- JVM 支持两种类加载器：引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，
	Java虚拟机规范：**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**
- 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222158803.png)
**EtcClassLoader**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222201408.png)

**AppClassLoader**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210222205572.png)

```java
public class ClassLoaderTest {  
    public static void main(String[] args) {  
        // 获取系统类加载器  
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();  
        System.out.println(systemClassLoader);
        //sun.misc.Launcher$AppClassLoader@18b4aac2  
  
        // 获取上层: 扩展类加载器  
        ClassLoader extClassLoader = systemClassLoader.getParent();  
        System.out.println(extClassLoader);
        //sun.misc.Launcher$ExtClassLoader@1b6d3586  
  
        // 获取上层: 无法获取引导类加载器  
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();  
        System.out.println(bootstrapClassLoader);
        //null  
  
        // 对于用户自定义类: 使用系统类加载器  
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();  
        System.out.println(classLoader);
        //sun.misc.Launcher$AppClassLoader@18b4aac2  
  
        // Java的核心类库全部使用引导类加载器加载  
        ClassLoader classLoader1 = String.class.getClassLoader();  
        System.out.println(classLoader1);
        //null  
    }  
}
```

无法获取 bootstrapClassLoader 的原因:
-  我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，**因为引导类加载器右 C/C++ 语言，我们获取不到**
- 两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明**系统类加载器是全局唯一的**

### 2.虚拟机自带加载器
#### 启动类加载器
> **启动类加载器（引导类加载器，Bootstrap ClassLoader）**

1) 这个类加载使用C/C++语言实现，嵌套在 JVM 内部
2)  它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供 JVM 自身需要的类
3)  并不继承自 java.lang.ClassLoader，没有父加载器
4)  加载扩展类和应用程序类加载器，并作为他们的父类加载器
5)  出于安全考虑，Bootstrap 启动类加载器只加载包名为java、javax、sun等开头的类

#### 扩展类加载器
>**扩展类加载器（Extension ClassLoader）**

1)  Java语言编写，由 sun.misc.Launcher$ExtClassLoader 实现
2)  派生于 ClassLoader 类
3)  父类加载器为启动类加载器
4)  从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。**如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载**

#### 系统类加载器
> **应用程序类加载器（也称为系统类加载器，AppClassLoader）**

1)  Java语言编写，由 sun.misc.LaunchersAppClassLoader 实现
2)  派生于 ClassLoader 类
3)  父类加载器为扩展类加载器
4)  它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库
5)  该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
6)  通过`classLoader.getSystemclassLoader()`方法可以获取到该类加载器

```java
public class ClassLoaderTest1 {  
    public static void main(String[] args) {  
        System.out.println("*************启动类加载器*************");  
        // 获取BootstrapClassLoader能够加载的api的路径  
        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();  
        for (URL element : urLs) {  
            System.out.println(element.toExternalForm());  
        }  
  
        // 从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器  
        System.out.println("*************扩展类加载器**************");  
        String extDirs = System.getProperty("java.ext.dirs");  
        for (String path : extDirs.split(";")) {  
            System.out.println(path);  
        }  
  
        //从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器  
        ClassLoader classLoader1 = CurveDB.class.getClassLoader();  
        System.out.println(classLoader1);  
        //sun.misc.Launcher$ExtClassLoader@1540e19d  
    }  
}
```

输出结果:
```text
*************启动类加载器*************
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/resources.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/rt.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/sunrsasign.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/jsse.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/jce.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/charsets.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/lib/jfr.jar
file:/D:/Dependency/Java/jdk1.8.0_202/jre/classes

*************扩展类加载器**************
D:\Dependency\Java\jdk1.8.0_202\jre\lib\ext
C:\Windows\Sun\Java\lib\ext

sun.misc.Launcher$ExtClassLoader@4b67cf4d
```

### 3.用户自定义类加载器
#### Why
> **何时需要自定义类加载器？**

在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？
1) 隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）
2) 修改类的加载方式
3) 扩展加载源，也可以考虑从数据库、路由器等等不同的地方加载类
4) 防止源码泄露：对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密

#### How
> **如何自定义类加载器?**

1) 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
2) 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中
3) 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。

**代码示例**
```java
public class CustomClassLoader extends ClassLoader {  
    @Override  
    protected Class<?> findClass(String name) throws ClassNotFoundException {  
  
        try {  
            byte[] result = getClassFromCustomPath(name);  
            if (result == null) {  
                throw new FileNotFoundException();  
            } else {  
                //defineClass和findClass搭配使用  
                return defineClass(name, result, 0, result.length);  
            }  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
  
        throw new ClassNotFoundException(name);  
    }  
    
	//自定义流的获取方式  
    private byte[] getClassFromCustomPath(String name) {  
        //从自定义路径中加载指定类:细节略  
        //如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。  
        return null;  
    }  
  
    public static void main(String[] args) {  
        CustomClassLoader customClassLoader = new CustomClassLoader();  
        try {  
            Class<?> clazz = Class.forName("One", true, customClassLoader);  
            Object obj = clazz.newInstance();  
            System.out.println(obj.getClass().getClassLoader());  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}
```
