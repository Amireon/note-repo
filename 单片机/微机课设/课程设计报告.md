# 一、设计内容

以STC8HK64U芯片为核心，设计一个光照强度检测装置，核心功能：

- 控制光传感器采集光照信息，
- 用4位数码管显示光照强度
- 实时检测工作环境：设定正常工作范围为[MIN, MAX]
- 使用蜂鸣器进行报警

具体为：每隔一段预先设定的时间，启动光传感器进行光照信息采集，使用ADC功能将模拟量转换为数字量，将信息进过某些处理后，使用4位数码管进行显示，在这过程中，LED将不断闪烁。当数码管显示的值小于某个设置的值MIN时，蜂鸣器将播放音乐；而当数码管的值大于某个设置的值MAX时，蜂鸣器将按固定方式响起，同时LED停止闪烁。在上述任意一个阶段，光传感器都按预先设定的工作方式工作。

# 二、整体结构

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250950315.jpg)

图1 硬件整体框图

图1展示了硬件的总体设计框图，单片机芯片选择STC8H8K64U，启动内部定时器T2，完成光传感器信息采集的定时任务，采集到的数据通过P10口输入MCU中，之后使用ADC进行数据处理。数码管的CLK、DIO分别连接到MCU的 P14、P15口上，显示ADC转换后的数据。蜂鸣器连接到P11口上，在特定情况下发出警告。外部中断启用INT1，用于改变MCU的控制条件。

光传感器模块。基于光敏电阻，工作原理是内光电效应：光照越强，阻值越小，电压越小，光敏电阻对光线十分敏感，在无光照时，呈高阻状态。使用单片机的ADC功能，将光传感器模块采集到的光信息从模拟量转换为数字量（电压）。

数码管显示模块。通过两总线接口CLK、DIO和TM1637通信，使用IIC控制共阳数码管在输入数据时，当CLK是高电平时，DIO上的信号必须保持不变；只有当CLK上的时钟信号为低电平时，DIO上的信号才能改变。数据输入的开始条件是CLK为高电平时，DIO由高变低；结束条件是CLK为高时，DIO由低电平变为高电平。

蜂鸣器报警模块。蜂鸣器是一种将电信号转换为声音信号的器件，常用来产生设备的按键音、报警音等提示信号，选取有源蜂鸣器，低电平触发，内部自带振荡源，将正负极接上直流电源即可持续发声，频率固定。

# 三、硬件电路设计

## （一）MCU供电电路

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250950049.jpg)

图2 MCU供电设计

图2展示了为MCU供电的电路设计，将P18和P19作为供电口，输入+5V电压，P20口作为GND，在VCC与GND之间就近添加电源去耦电容22uF和0.1uF，可去除电源线噪声，提高抗干扰能力。MCU供电来源自USB，另外使用两列排针连接MCU，用于扩展管脚，后续许多元器件将连接在排针上。

## （二）ISP下载电路

现在STC的带硬件USB的MCU支持用硬件USB下载，使用USB-HID通信协议，不需要安装任何驱动。图3是ISP下载电路，使用直接连接USB（使用Type-C）进行下载，按住图中的按钮然后连接USB，方可进行ISP下载；若连接USB时没有按住此按钮，则不会进入ISP，而是直接运行用户代码。此外，使用USB直接下载不能调节内部IRC的频率，只能在下载时选择内部预置的常用频率，本设计选择12MHz。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250950977.jpg)

图3 ISP下载电路

## （三）友好的用户界面

图4为LED显示电路，使用8个LED连接在MCU的P2管脚上，添加了8个470欧姆的上拉电阻，用于保护LED。这8个LED灯的作用为调试单片机，并作为外部交互装置。为了优化使用体验，添加了拨码开关，允许选择是否打开LED显示。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250950204.jpg)

图4 LED显示

图5是额外添加的，用于优化使用体验的模块，图5（a）添加了三个外部按键，供开发时使用，还额外放置了一个拨码开关用于控制这三个按键的启用与否。图5（b）是一个简单的单片机启动显示装置，用于辅助用户判断单片机是否在正常工作。图5（c）用于放置排针，预留了VCC、+5V和GND三个电源选项，可以使用杜邦线连接一些模块，用于进一步开发功能。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250950648.jpg)

图5优化交互

# 四、软件设计

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202306250951124.jpg)

图6 软件系统活动图

图6为本项目软件部分的总体执行过程，使用定时器中断触发定时任务，保证单片机一直处于工作状态，减少各模块串行工作带来的部分问题。单片机软件的具体工作流程为，在MCU中设置一个定时器用于启动定时任务，该任务将启动一次光传感器进行光照信息采集，在MCU中通过ADC接收模拟量，转换为数字量，返回给调用函数，定时任务得到数字量的光照信息后，传递给数码管显示，然后将其与给定的上下限比较，若小于下限，将启动蜂鸣器播放音乐；若大于上限，则让蜂鸣器保持蜂鸣同时LED停止闪烁；若处于上下限之间，则将LED和蜂鸣器都恢复至初始状态（LED保持闪烁，蜂鸣器保持静音），此次定时任务执行结束，等待下次任务开始。

算法1定时器2中断

```c
void Timer2_Isr() interrupt 12 {
        count--;
        if(count == 0) {
           count = 50;
           ldegree = OPS_Get();                  
           TM1637_DisplayInt(ldegree);              
           Check_Ldegree();                               
           P2 = ~P2;
  }
}
```

本设计使用定时器T2，定时长度为250ms，即每间隔250ms就启动一次检测任务， 为保证代码执行的因果关系（即顺序性），上述工作流程均在定时器触发的中断中进行，如算法1所示。在主函数中只保留一个用于检测蜂鸣器状态的功能，不断轮询给蜂鸣器设定的工作条件，当满足工作条件时，将启动蜂鸣器播放音乐。

算法2 ADC获取数据

```c
unsigned int OPS_Get( ) {
    ADC_CONTR |= 0x40;             // 启动AD转换
    _nop_();
    _nop_();
    while (!(ADC_CONTR & 0x20));     // 查询ADC完成标志
    ADC_CONTR &= ~0x20;           // 清完成标志
    light = ADC_RES;                 // 读取ADC结果
    light = light * 256;
    light += ADC_RESL;                       // 电压公式=light*3.3/4095
    return light;
}
```

    光传感器传输的数据是模拟量，需要借助ADC功能将模拟量转换为数字量，由于不使用USB传输数据，因此可以只关注ADC的过程。如算法2所示，首先启动AD转换，当ADC完成后，读取ADC结果并预处理得到light，光敏电阻两侧的电压值等于 light * 3.3 / 4095，而light的最大值也不超过4500，那么该电压值的变化范围最大为(0,3)，而light的变化范围为(0,4500)，因此直接将light返回给调用函数。

算法3 外部控制

```c
void INT1_Isr() interrupt 2 {
    Ceiling = (++Ceiling) % 9;
    if(Ceiling <= Floor) {
         Ceiling = 1 + Floor;
    }
    Buzz = 0;
    while(!K3);
    Buzz = 1;
}
```

为了允许动态调整光照检测的上限（最暗值），添加了一个按钮，连接MCU的外部中断INT1，将light的上限按500的粒度划分为3, 4, 5, 6，7，8等档次，按键每按下一次，上限跳至下一档，直至最低挡，但是上限始终大于等于下限值加1。此外，在按下按钮时，蜂鸣器将响起，直至抬起按钮。

算法4 工作模式控制

```c
void Check_Ldegree(){
    if(ldegree < Floor * 500){
             Beep_Set(1);
    }
    else if(ldegree > Ceiling * 500){
             LED_Flag = 1;  
             Beep_Set(0);
             Buzz = 0;
             P2 = 0x00;
    } else if(LED_Flag == 1){ // 避免频繁修改
             LED_Flag = 0;
             Beep_Set(0);
             Buzz = 1;
             P2 = 0xaa;
    }
}
```

算法4 实现了根据光照强度改变单片机工作方式的功能，检测光照强度是否在设定的范围之内，若小于设定范围，则启动蜂鸣器，播放音乐，具备断点续播功能；若大于设定范围，则蜂鸣器保持蜂鸣，LED停止闪烁。此外，设置了一个LED_Flag变量，用于辅助判断，避免频繁修改MCU内部状态，提高系统可靠性。

# 五、测试及改进

## （一）触发定时任务的定时器设置

STC8H8K64U提供了定时器T0，定时器T1，定时器T2，定时器T3，定时器T4这5个定时器中断，T0和T1已经被蜂鸣器占用，用于播放音乐，因此选择T2作为定时任务的触发器。使用STC官方提供的定时器计算器，选择12MHz，定时长度选择250毫秒，设定24位自动重载，可得到计时250毫秒的算法5。

算法5 计时250ms的24位自动重载的定时器2

```c
void Timer2_Init(void)     {       //250毫秒@12.000MHz
    TM2PS = 0x2D;                 
    AUXR |= 0x04;                  
    T2L = 0x3F;                               
    T2H = 0x01;                               
    AUXR |= 0x10;                  
}
```

测试，定时任务并没有执行，即定时器没有被触发，可能的原因有：

- 定时器定时成功，但是定时器中断没有启动；
- 定时器定时失败。

显然，现在无法证明定时器中断未被触发，只能从定时器没有成功定时这一可能出发。在翻阅了STC8H系列的手

册后，在“14定时器/计数器”这一章节中得知，“定时器T2的工作模式固定为16位自动重装载模式。”其次，在仔细

翻阅了STC-ISP自动生成的代码后，了解到并非所有的STC系列的单片机都有TM2PS这个寄存器。综上，真正的原

因是错误设置了T2的工作模式，正确的方式应该是16位自动重载，在定时器时钟为1T模式下最多定时5ms，12T

模式下最多定时65ms，均无法满足250ms的要求，只能选择额外设置一个计数器，用于计算定时器触发的次数，

进而定时250ms。因此，T2最终的设置为，系统频率12MHz，定时长度5ms，16位自动重载，时钟模式为12T。

算法6 定时器2定时设置

```c
void Timer2_Init() { // 定时器T2启动, [5毫秒@12.000MHz](mailto:5毫秒@12.000MHz)
        AUXR &= 0xFB;        //定时器时钟12T模式
        T2L = 0x78;          //设置定时初始值
        T2H = 0xEC;          //设置定时初始值
        AUXR |= 0x10;        //定时器2开始计时
        IE2 = 0x04;          //使能定时中断
}
```

## （二）4位数码管显示

（实际上是大自然的搬运工。）

显示数据的4位数码管使用TM1637驱动，但是STC并没有官方的启动库文件，只能自行编写。

数据输入的开始条件是CLK为高电平时，DIO由高变低。

算法7 IIC开始

```c
void TM1637_start(){          // IIC开始
    CLK = 1;
    DIO = 1;
    Delay_us(2);
    DIO = 0;
}
```

数据输入的结束条件是CLK为高时，DIO由低电平变为高电平。

算法8 IIC结束

```c
void TM1637_stop(){   // IIC结束
    CLK = 1;
    DIO = 0;
    Delay_us(2);
    DIO = 1;
}
```

TM1637的数据传输带有应答信号ACK，当传输数据正确时，会在第八个时钟的下降沿，芯片内部会产生一个应答信号ACK将DIO管脚拉低，在第九个时钟结束之后释放DIO口线。

算法9 IIC应答

```c
void TM1637_ack(){
    unsigned char i;
    CLK = 0; Delay_us(5);
    While(DIO == 1 && (i < 250)) i++;
    CLK = 1; Delay_us(2);
    CLK = 0;
}
```

# 六、小结

这次课程设计基于每周课程的单片机Demo，实质上是对所学知识的一次综合检验，从对单片机整体结构的把握，到简单使用其各个组成部分的功能，如程序烧录、I/O口传输数据、按键的程序判断，外部中断、内部定时器和USB传输数据等。本次课程设计将硬件与软件结合，较好地检验了单片机开发的入门功底，接下来便是“修行靠个人”的过程了。

# 参考文献

[1] wanglong3713, 4位数码管显示模块TM1637芯片C语言驱动程序[EB/OL](2022-05-17) [2023-06-19], https://blog.csdn.net/wanglong3713/article/details/121110104

[2] 黑暗中的一束光1023, TM1637芯片使用（I2C总线协议学习），[EB/OL](2021-02 -16) [2023-06-19], https://blog.csdn.net/qq_43145360/article/details/113822632

[3] 无乎648, 单片机课设-电子时钟设计[EB/OL](2022-06-18)[2023-06-19], [https://blog.csdn.net/WUHU648/article/details/118459987](https://blog.csdn.net/WUHU648/article/details/118459987)

[4] 搞IC的小冯, 【STC单片机学习】第十一课：蜂鸣器[EB/OL](2020-11-16) [2023-06-19], [https://blog.csdn.net/qq_27148893/article/details/109719101](https://blog.csdn.net/qq_27148893/article/details/109719101)

[5] 自小吃多, STC8H_ADC函数使用[EB/OL]( 2022-09-13)[2023-06-19], [https://blog.csdn.net/weixin_41226265/article/details/126826401](https://blog.csdn.net/weixin_41226265/article/details/126826401)

[6] STC,STC8H系列技术手册[EB/OL][2023-06-19], [http://stcai.com](http://stcai.com)