# 7.1 机器指令
> 本章主要介绍机器指令系统的分类，常见的寻址方式、指令格式，也简要介绍了 RISC 技术
> 
> 人们习惯把每一条机器语言的语句称为机器指令，将全部机器指令的集合称为机器的指令系统
>

**章节总览**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301139831.png)

## 指令格式-地址码
`指令=操作码字段+地址码字段`

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301705386.png)

### 指令格式-操作码
1. 操作码指出指令中该指令应该执行什么性质的操作和具有何种功能
2. 操作码是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。例
如，指出是算术加运算，还是减运算；是程序转移，还是返回操作。

#### 操作码分类
**1. 定长操作码**
含义：在指令字的最高为部分分配固定的若干位（定长）表示操作码
一般n位操作码字段的指令系统最大能够表示 $2^n$ 条指令

- 优：定长操作码对于简化计算机使件设计，提高指令译码和识别速度很有利
- 缺：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限

**2.扩展操作码(不定长操作码)**：
含义：全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上
最常见的变长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的
指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

- 优：在指令字长有限的前提下仍保持比较丰富的指令种类;
- 缺：增加了指令译码和分析的难度，使控制器的设计复杂化

#### 扩展操作码
**注意事项**：
- 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
- 各指令的操作码一定不能重复

通常情况下，对使用频率较高的指令，分配较短的操作码：
对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301711272.png)

**例题**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301713320.png)

# 7.2 操作数类型和操作类型
**1.数据传送**
数据传送类：进行主存与 CPU 之间的数据传送
- `LOAD`：把存储器中的数据放到寄存器中
- `STORE`：把寄存器中的数据放到存储器中

**2.算术逻辑操作**
运算类
- 算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
- 逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

**3.移位操作**
算术移位、逻辑移位、循环移位（带进位和不带进位）

**4.转移操作**
程序控制类：改变程序执行的顺序
- 无条件转移`JMP`
- 条件转移`JZ`：结果为0;JO：结果溢出；JC：结果有进位
- 调用`CALL`，返回`RETURN`
- 陷阱`Trap`与陷阱指令

**5.输入输出操作**
输入输出类（I/0）：进行CPU和I/0设备之间的数据传送
- CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)

机器字长：CPU一次性能处理的二进制数据的位数
指令字长：一个指令字中包含二进制代码的位数
存储字长：一个存储单元中存储二进制代码的长度

# 7.3 寻址方式
寻址方式：确定本条指令的数据地址以及下一条将要执行的指令地址的方法，
寻址方式分为两种：
1. 指令寻址：下一条欲执行指令的指令地地
 2. 数据寻址：确定本条指令的操作数地址

## 1.指令寻址
指令寻址如何定位下一条指令的地址：**始终由程序计数器给出**
基本方式有两种：
- 顺序寻址：（PC）+ 1 ——> PC
- 跳跃寻址：由转移指令给出

**例题**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301218527.png)

前3条指令的执行方式一致：PC读入指令地址，执行完毕后 （PC）——> PC，
当指令地址为3时，操作码是 JMP，意味着 PC 需邀跳转至该条指令地址码的位置

## 2.数据寻址
指令的地址码字段通常都不代表操作数的真实地址，称为形式地址，记为 A
操作数的真实地址称为有效地址，记作 EA
指令的格式：$操作码+寻址特征+形式地址A$
 
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301647780.png)

### 直接寻址
**直接寻址**：指令字中的形式地址 A  就是操作数的真实地址 EA，即 EA = A

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301534884.png)

**执行一条指令的访存次数**：2次，因为取指令访存一次，执行指令访存1次，
**优点**：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址
**缺点**：A的位数限制了指令操作数的寻址范围；操作数的地址不易修改

### 间接寻址
**间接寻址**：指令字中的地址不直接给出操作数的地址，而是给出操作数有效地址所在的存储单元地址，也就是，有效地址是由形式地址间接提供的，即 EA = （A）
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301729356.png)

**执行一条指令的访存次数**：3次，因为取指令访存1次，执行指令访存2次
**优点:**
- 可扩大寻址范围，有效地址EA的位数大于形式地址A的位数
- 便于编制程序，用间接寻址可以方便地完成于程序返回
**缺点:**
- 指令在执行阶段要多次访存，一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存

### 寄存器寻址
**寄存器寻址**：在指令字中，地址码字段直接给出操作数所在的寄存器编号，即 EA= $R_i$ ，其操作数在由 $R_i$ 所指的寄存器内
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301546282.png)
**访存次数**：1次，因为取指令访存1次，执行指令访存0次
**优点：**
- 指令在执行阶段不访问主存，只访问寄存器
- 指令字短且执行速度快，支持向量、矩阵运算
**缺点：**
- 寄存器价格昂贵，个数有限

### 寄存器间接寻址
**寄存器间接寻址：** 寄存器 $R_i$ 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=($R_i$)
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301548674.png)

**访存次数：** 2次，因为取指令访存1次，执行指令访存1次
**特点**：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存(因为操作数在主存中)


### 隐含寻址
**隐含寻址**：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址·
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301551479.png)
**优点**：有利于缩短指令字长
**缺点**：需增加存储操作数或隐含地址的硬件


### 偏移寻址
基址寻址：EA=(BR)+A
变址寻址：EA=(IX)+A
相对寻址：EA=(PC)+A
>![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301421260.png)


#### 基址寻址
**基址寻址**：将CPU 中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地 
址，即 EA = （BR）+ A

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301557312.png)
> 注：基址寄存器是**面向操作系统**的，其**内容由操作系统或管理程序确定**。
> 在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。
> 当采用通用寄存器作为基址寄存器 时，可由用户决定哪个寄仔器作为基址奇仔器，但其内容仍由操作系统确定

**优点**：
- 可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）
- 用户不必考虑程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301606619.png)


#### 变址寻址
**变址寻址**：有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即EA= (IX)+A
IX可以是专用的变址寄存器，也可以是通用寄存器

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301610638.png)
>注：变址寄存器是**面向用户**的，在程序执行过程中，**变址寄存器的内容可由用户改变**(作为偏移量），形式地址A不变（作为基地址）

**优点**：
- 扩大寻址范围，变址寄存器的位数大于形式地址A的位数
- 在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任数据的地址，特别适合**编制循环程序**

基址寻址与变址寻址
![基址寻址与变址寻址](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301633655.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301636567.png)

#### 相对寻址
**相对寻址**：有效地址是将程序计数器 PC 的内容（即当前指令的地址）与指令字中的形式地址 A 相加而成，即 EA = (PC) + A，其中A是相对于当前指令地址的位移量，可正可负，补码表示。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301628644.png)

**优点**：操作数的地址是不固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值， 便于程序浮动
相对寻址广泛应用于**转移指令**


###  堆栈寻址
**堆栈寻址**：操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301658223.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210301658531.png)

## CISC和RISC
