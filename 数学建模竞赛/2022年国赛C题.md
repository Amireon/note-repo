#国赛
## 问题 1
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915181404.png)

1） 分类目标：是否风化，
		分类之后，突出一下特征重要性？变量取值对玻璃文物的表面风化的影响程度

2）依据玻璃类型划分两类文物，分别研究统计规律
任务：
	-  寻找致表面风化的化学成分
	- 预测： 还原风化前的组成成分
		

思路：
1）卡方检验
2）根据表单1
风化化学成分含量的做法：特征变量的显著性检验，可以得出哪个变量与是否风化关系紧密

想法：将数据分为未分化的和已风化的，把未分化的数据当做自变量 x ，输入进预测模型，得出其风化后的各成分含量 y ，把已风化的样品与 y 比较，距离近的可以近似认为是 x 的结果，那么 x 就是已风化的文物未分化前的化学成分含量
问题：预测模型

预测其风化前的化学成分含量：
	1）平均值
	2）预测，已知条件：各采样点的风化状态，使用聚类的簇的中心点的数值？
	
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220916160306.png)

规律寻找
	四个阶段
	 - 穷举，成分表排列，寻找风化规律，建立函数
	 - 现有玻璃成分表变化规律
	 -

> 从”3 花岗岩风化程度遥感快速划分方法“ ：总计可以判断结论的规律
> 划分范围：
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220916171426.png)

2）预测已风化的样品在未风化前的组成成分
从附件一中列出纹饰、颜色、类型一致的一类样品，然后这样的数据一定是多组的，然后是否可以认为同类样品中已风化的样品的数据是否与未风化的样品是一致的？

对于某些组合可能是全未风化的或者是已风化的，可以采用（1）的关系分析，使用影响不大的数据组作为替代，例如如下情况，就可以用第一组数据求第二组数据，而且对于全部风化的类来说没有必要进行聚类分析，
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220916212816.png)


处理思路：
	- 统计分析学？众数，三分点，或者直接平均值？结果得要区间
	- 再再次聚类？得到唯一簇中心，坐标可以当做未风化的初值，或许可以多次聚类，
		- 将簇中心再次聚类？（套娃 ×）
		- 或者将多个簇中心的坐标当做区间的上下界
	- 规划？



## 问题 2
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915183724.png)

1）分类规律：Sheet2是化学组成分类，根据Sheet2来
	找出化学成分含量对两类玻璃分类的判断点，在哪个点或范围内可以认为是哪种类型玻璃
	Sheet2：化学组成  ===>>   突出化学物质的含量分为两大类，某个取值范围
	构建一个可解释的机器学习分类模型，例如决策树、逻辑回归，以类型(高钾玻璃、铅钡玻璃)为Y，尽可能构建足够多的特征X，形成可解释的分类规律，
	
2）亚类划分：
	优化 （1）的分类依据，根据占比稀少的化学物质的含量分类

> 通过钙铝及其它微量元素将钾玻璃分成3个亚类,它们可能有不同的配方及制造中心;
	[1]斯琴毕力格,李青会,干福熹.激光剥蚀-电感耦合等离子体-原子发射光谱/质谱法分析中国古代钾玻璃组分[J].分析化学,2013,41(09):1328-1333.


3）分类结果的合理性和敏感性：使用测试集或评价模型



## 问题 3
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915201330.png)
1）依据`问题2` 的结果进行分类

2）敏感性分析：待查




## 问题 4
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915185532.png)

及其开放的题目，言之有理即可（。。）
1）此多彼少？
2）


## 代码
。。。学艺不精，我选python

首要目标：*数据预处理*

![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915194539.png)


库：
	- 分类用的决策树
	- 特征重要性的函数?(查找中)
	- 数据预处理的 `preprocessing`


卡方检验：
```python
from scipy.stats import chi2_contingency  
import numpy as np  

x = [[82,48], [55,30]]
obs = np.array(x)  
print(chi2_contingency(obs, correction=True))
```

灰色预测
或许可以拿未风化的数据往后预测其什么时候会风化
问题：预测模型是对同一对象的不同时期
把所有数据当做同一对象的多组数据，按SiO2的含量进行排序，？
暂定
```python
# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
 
 
def GM11(x, n):
    '''
    灰色预测
    x：序列，numpy对象
    n: 需要往后预测的个数
    '''
    x1 = x.cumsum()  # 一次累加
    z1 = (x1[:len(x1) - 1] + x1[1:]) / 2.0  # 紧邻均值
    z1 = z1.reshape((len(z1), 1))
    B = np.append(-z1, np.ones_like(z1), axis=1)
    Y = x[1:].reshape((len(x) - 1, 1))
    # a为发展系数 b为灰色作用量
    [[a], [b]] = np.dot(np.dot(np.linalg.inv(np.dot(B.T, B)), B.T), 
					    Y)  # 计算参数
    result = (x[0] - b / a) * np.exp(-a * (n - 1)) - (x[0] - b / a) 
		    * np.exp(-a * (n - 2))
    S1_2 = x.var()  # 原序列方差
    e = list()  # 残差序列
    for index in range(1, x.shape[0] + 1):
        predict = (x[0] - b / a) * np.exp(-a * (index - 1)) - 
			        (x[0] - b / a) * np.exp(-a * (index - 2))
        e.append(x[index - 1] - predict)
    S2_2 = np.array(e).var()  # 残差方差
    C = S2_2 / S1_2  # 后验差比
    if C <= 0.35:
        assess = '后验差比<=0.35，模型精度等级为好'
    elif C <= 0.5:
        assess = '后验差比<=0.5，模型精度等级为合格'
    elif C <= 0.65:
        assess = '后验差比<=0.65，模型精度等级为勉强'
    else:
        assess = '后验差比>0.65，模型精度等级为不合格'
    # 预测数据
    predict = list()
    for index in range(x.shape[0] + 1, x.shape[0] + n + 1):
        predict.append((x[0] - b / a) * np.exp(-a * (index - 1)) - 
				        (x[0] - b / a) * np.exp(-a * (index - 2)))
    predict = np.array(predict)
    return {
        'a': {'value': a, 'desc': '发展系数'},
        'b': {'value': b, 'desc': '灰色作用量'},
        'predict': {'value': result, 'desc': '第%d个预测值' % n},
        'C': {'value': C, 'desc': assess},
        'predict': {'value': predict, 'desc': '往后预测%d个的序列' % (n)},
    }
 
 
if __name__ == "__main__":
    data = np.array([1.2, 2.2, 3.1, 4.5, 5.6, 6.7, 7.1,
				     8.2, 9.6, 10.6, 11, 12.4, 13.5, 14.7, 15.2])
    x = data[0:10]  # 输入数据
    y = data[10:]  # 需要预测的数据
    result = GM11(x, len(y))
    predict = result['predict']['value']
    predict = np.round(predict, 1)
    print('真实值:', y)
    print('预测值:', predict)
    print(result)
 
```