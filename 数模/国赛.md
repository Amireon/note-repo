## 问题 1
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915181404.png)

1） 分类： 决策树应该不错
分类目标：是否风化，
		分类之后，突出一下特征重要性？变量取值对玻璃文物的表面风化的影响程度

2）依据玻璃类型划分两类文物，分别研究统计规律
> 风化点：该部位已风化，非风化的各成分含量组成点

任务：
	-  寻找致表面风化的化学成分
	- 预测： 还原风化前的组成成分
		
成分含量达标的与不达标的分为两类：剔除含量不达标的，（后续可以作为模型测试集

思路：
1）卡方检验
2）根据表单1
风化化学成分含量的做法：特征变量的显著性检验，可以得出哪个变量与是否风化关系紧密

想法：将数据分为未分化的和已风化的，把未分化的数据当做自变量 x ，输入进预测模型，得出其风化后的各成分含量 y ，把已风化的样品与 y 比较，距离近的可以近似认为是 x 的结果，那么 x 就是已风化的文物未分化前的化学成分含量
问题：预测模型


## 问题 2
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915183724.png)

1）分类规律：Sheet2是化学组成分类，根据Sheet2来
	找出化学成分含量对两类玻璃分类的判断点，在哪个点或范围内可以认为是哪种类型玻璃
		最基础的判断：
				- 铅钡玻璃： PbO、BaO 
				- 高钾玻璃：K2O

2）每个类别？？？在（1）的基础上细分？==> 优化
亚类划分：将剩下的化学成分穷举试错？叉
	估计和（1）一样：细分判断条件（优化）

合理性和敏感性：评价

## 问题 3
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915201330.png)

1）依据`问题2` 分类
2）敏感性分析：待查


## 问题 4
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915185532.png)

及其开放的题目，言之有理即可（。。）
1）此多彼少？
2）


## 代码
。。。学艺不精，我选python

首要目标：*数据预处理*

![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/20220915194539.png)


库：
	- 分类用的决策树
	- 特征重要性的函数?(查找中)
	- 数据预处理的 `preprocessing`


卡方检验：
```python
from scipy.stats import chi2_contingency  
import numpy as np  

x = [[82,48], [55,30]]
obs = np.array(x)  
print(chi2_contingency(obs, correction=True))
```

灰色预测
或许可以拿未风化的数据往后预测其什么时候会风化
问题：预测模型是对同一对象的不同时期
把所有数据当做同一对象的多组数据，按SiO2的含量进行排序，？
暂定
```python
# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
 
 
def GM11(x, n):
    '''
    灰色预测
    x：序列，numpy对象
    n: 需要往后预测的个数
    '''
    x1 = x.cumsum()  # 一次累加
    z1 = (x1[:len(x1) - 1] + x1[1:]) / 2.0  # 紧邻均值
    z1 = z1.reshape((len(z1), 1))
    B = np.append(-z1, np.ones_like(z1), axis=1)
    Y = x[1:].reshape((len(x) - 1, 1))
    # a为发展系数 b为灰色作用量
    [[a], [b]] = np.dot(np.dot(np.linalg.inv(np.dot(B.T, B)), B.T), 
					    Y)  # 计算参数
    result = (x[0] - b / a) * np.exp(-a * (n - 1)) - (x[0] - b / a) 
		    * np.exp(-a * (n - 2))
    S1_2 = x.var()  # 原序列方差
    e = list()  # 残差序列
    for index in range(1, x.shape[0] + 1):
        predict = (x[0] - b / a) * np.exp(-a * (index - 1)) - 
			        (x[0] - b / a) * np.exp(-a * (index - 2))
        e.append(x[index - 1] - predict)
    S2_2 = np.array(e).var()  # 残差方差
    C = S2_2 / S1_2  # 后验差比
    if C <= 0.35:
        assess = '后验差比<=0.35，模型精度等级为好'
    elif C <= 0.5:
        assess = '后验差比<=0.5，模型精度等级为合格'
    elif C <= 0.65:
        assess = '后验差比<=0.65，模型精度等级为勉强'
    else:
        assess = '后验差比>0.65，模型精度等级为不合格'
    # 预测数据
    predict = list()
    for index in range(x.shape[0] + 1, x.shape[0] + n + 1):
        predict.append((x[0] - b / a) * np.exp(-a * (index - 1)) - 
				        (x[0] - b / a) * np.exp(-a * (index - 2)))
    predict = np.array(predict)
    return {
        'a': {'value': a, 'desc': '发展系数'},
        'b': {'value': b, 'desc': '灰色作用量'},
        'predict': {'value': result, 'desc': '第%d个预测值' % n},
        'C': {'value': C, 'desc': assess},
        'predict': {'value': predict, 'desc': '往后预测%d个的序列' % (n)},
    }
 
 
if __name__ == "__main__":
    data = np.array([1.2, 2.2, 3.1, 4.5, 5.6, 6.7, 7.1,
				     8.2, 9.6, 10.6, 11, 12.4, 13.5, 14.7, 15.2])
    x = data[0:10]  # 输入数据
    y = data[10:]  # 需要预测的数据
    result = GM11(x, len(y))
    predict = result['predict']['value']
    predict = np.round(predict, 1)
    print('真实值:', y)
    print('预测值:', predict)
    print(result)
 
```