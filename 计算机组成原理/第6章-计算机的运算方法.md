本章主要介绍参与运算的各类数据（无符号数和有符号数、定点数和浮点数等），以及它们在计算机中的算术运算方法。

# 6.1 无符号数和有符号数
通常称寄存器的位数为机器字长

- 无符号数：没有符号的数（那不就是正数），寄存器中的每一位都用来存放数值
- 有符号数：寄存器留出位置存放符号

机器数与真值：带符号的数："+"，"-", "0", "1"

### 1.四种码制

| 类型 | 定义 | 表示范围(n+1位，1位符号位)                                                         | 作用                                 |
| ---- | ---- | ---------------------------------------------------------------------------------- | ------------------------------------ |
| 原码 |      |                                                                                    | 带符号的绝对值表示                   |
| 补码 |      |                                                                                    | 化减法运算为加法运算                 |
| 反码 |      |  | 由原码求补码或由补码求原码的中间过渡 |




### 2.码制转换
![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210122124614.png)
- 对于正数，符号位恒为0，原码 = 补码 = 反码
- 对于负数，符号位恒为1，
	- 原码求补码，补码求原码，操作一致：符号位不变，数值位每位求反，末位加1
	- 求反码：原码符号位不变，数值位按位取反；或补码末位减1
- 无论正负，[y]补求[-y]补：连同符号位在内，每位取反，末位加1
- 无论正负，求移码：将补码的符号位取反，数值位不变



# 6.2 定点数和浮点数
## 1.定点数的表示
小数点按约定的方式标出，小数点位于
 - 符号位和第一数值位之间：纯小数
 - 数值位之后：纯整数

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271612004.png)

**原码、补码、反码在定点数中的表示范围：** 数值位为n位

| 定点机 | 小数定点机 | 整数定点机 |
| ------ | ---------- | ---------- |
| 原码   |          -(1-2<sup>-n</sup>)~+(1-2<sup>-n</sup>) | -(2<sup>n</sup>-1)~+(2<sup>n</sup>-1) |
| 补码   | -1~+(1-2<sup>-n</sup>)      | -2<sup>n</sup>~+(2<sup>n</sup>-1)     |
| 反码   | -(1-2<sup>-n</sup>)~+(1-2<sup>-n</sup>) |  -(2<sup>n</sup>-1)~+(2<sup>n</sup>-1)  |

## 2.浮点数的表示
**1.浮点数的表示形式**

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271615567.png)
各参数的意义如下：
 - `Sf`： 浮点数的符号位
 - `n`：尾数的位数，反映浮点数的精度
 - `m`：阶码的位数，反映浮点数的表示范围
 - `jf和m`：共同表示小数点的实际位置，~~这条没什么用~~

机器零：
 - 当浮点数尾数为0时，不论阶码为何值，按机器零处理
 - 当浮点数阶码等于或小于所能表示的最小值时，不论尾数为何值，按机器零处理

**2.浮点数的表示范围**

![浮点数的表示范围](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271648293.png)

>练习：设机器字长为24位，与表示正负3万的十进制数，试问在保证数的最大精度的前提下，除阶符、数符各取1位外，阶码、尾数各取几位？
>![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271652520.png)

**3.浮点数的规格化表示**
 - 基数 r 越大，可表示的浮点数的范围越大
 - 基数 r 越大，浮点数的精度降低


>例6.15
>![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271655730.png)

![](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210122211062.png)

# 6.3 定点数运算
## 1.移位运算
**1.  算术移位**
有符号数，无论是正数还是负数，移位时符号位保持不变

算术移位规则：
- 正数：原码、补码、反码移位均添0
- 负数：
	- 原码：都添0
	- 补码：左移添0，右移添1
	- 反码：都添1

**2. 逻辑移位**
  无符号数，移位规则：
   - 逻辑左移，低位添0，高位移丢；
   - 逻辑右移，高位添0，低位移丢.

## 2.加减运算
**1. 加减法运算**
- 减法运算可以看做被减数加上一个减数的负值，即 $A -B = A + (-B)$ 
- 因此若机器数采用补码，当求 A- B 时，只需先求[-B]<sub>补</sub> 就可按补码加法规则进行运算
- 求 [-B]<sub>补</sub> ：将[-B]<sub>补</sub> 连同符号位在内每位取反。末位 +1
- 减法运算连同符号位一起运算，符号位产生的进位直接丢弃
| 类型 | 加法 | 减法 |
| ---- | ---- | ---- |
| 整数 |   $[A]_补+[B]_补=[A+B]_补(mod 2^{n+1})$   |  $[A-B]_补 = [A]_补 + [-B]_补(mod 2^{n+1})$   |
| 小数 |   $[A]_补+[B]_补=[A+B]_补(mod 2)$   | $[A-B]_补 = [A]_补 + [-B]_补(mod 2)$     |

**2. 溢出判断**   
补码定点加减法运算判断溢出有两种方法
| 方法       | 溢出判断                                           | 硬件实现                                  |
| ---------- | -------------------------------------------------- | ----------------------------------------- |
| 一位符号位 | 参加操作的两个数符号相同，而运算结果的符号与其不同 | $最高有效位的进位\bigoplus符号位的进位=1$ |
| 两位符号位（变形补码） |2位符号位不同即溢出，而无论是否溢出，高位符号位代表真实符号 |$符号位产生的进位\bigoplus最高有效位产生的进位=1$|

 ## 3.乘法运算
 ### 原码乘法
**1.原码一位乘**和原码两位乘
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271739934.png)
原码一位乘运算规则：
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271740977.png)
**2.原码两位乘**

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271742931.png)
**原码两位乘运算规则**、
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271743652.png)
**原码一位乘和原码两位乘比较**
| 科目         | 原码一位乘         | 原码两位乘         |
| ------------ | ------------------ | ------------------ |
| 符号位       | $x_0\bigoplus y_0$ | $x_0\bigoplus y_0$ |
| 操作数       | 绝对值             | 绝对值的补码       |
| 移位         | 逻辑右移           | 算术右移           |
| 移位次数     | n                  | $\frac{n}{2}$,n为偶数      |
| 最多加法次数 | n                  | $\frac{n}{2}+ 1$，n为偶数                  |
### 补码乘法
**1.补码一位乘**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271750605.png)

补码一位乘运算公式：
$$[x*y]_{补}=[x]_{补}*[y]_{补}=[x]_{补}*(0y_{1}y_{2}...y_{n})+[-x]_{补}*y_{0}$$

Booth算法递推公式
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271817887.png)

补码乘法小结
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271818939.png)


## 4.除法运算
### 原码除法

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210271820593.png)

特点：
 - 上商 n + 1次
 - 第一次上商判溢出
 - 移 n 次，加 n + 1 次
 - 用移位的次数判断除法是否已经结束

## 6.4浮点数运算
## 1.加减运算
>步骤： 对阶、尾数求和、规格化、舍入

**1.对阶**
先求阶差  $j_{x}-j_{y}$  判断正负，然后对阶
对阶原则：小阶向大阶看齐
尾数要根据阶码的移动而移动

**2.尾数求和**
补码求和，~~没啥好说的~~

**3.规格化**
规格化数的定义：$r=2, \frac{1}{2}<=|S|<1$
规格化数的判断：
 - 原码：无论正负，第一数值位需要为1
 - 补码：符号位和第一数值位不同

> 例：字长12位， 用定点补码规格化小数表示时,所能表示的正数范围是( )。
> $\frac{1}{2}$ ~ $(1- 2^{-11} )$

特例：$[-\frac{1}{2}]_补$ 不是规格化的数，$[-1]_补$ 是规格化的数

左规：尾数左移一位，阶码减1，直到数符合第一数位不同为止
右规：当尾数溢出（>1）时，尾数右移一位，阶码加1

**4.舍入**
在 对阶 和 右规 过程中，可能出现 尾数末位丢失 引起误差，需考虑舍入
0 舍 1 入法，恒置 “1” 法
