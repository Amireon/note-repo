# 第2章 类加载子系统
## 1.内存结构概述
![简图](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161943803.png)

详细图
![详细_英文](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161942461.png)

中文版
![详细_中文](https://raw.githubusercontent.com/Anlieh/PicBucket/master/202210161944508.png)

## 2.类加载器子系统
**类加载器子系统的作用：**
- 类加载器子系统负责从文件系统或者网络中加载 .class 文件，.class 文件在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
- **加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
![02_类加载器的作用](https://ypic.oss-cn-hangzhou.aliyuncs.com/20221018140320.png)

### ClassLoader
1. class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。
2. class file 加载到 JVM 中，被称为 DNA 元数据模版，放在方法区
3. 在 .class 文件 ---> JVM --->最终成为元数据模板，此过程就要一个运输工具（类加载器Class Loader）扮演一个快递员的角色
![类加载器ClassLoader角色](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210211947176.png)
## 3.类的加载过程
```java
public class HelloLoader {  
  
    public static void main(String[] args) {  
        System.out.println("谢谢ClassLoader加载我....");  
        System.out.println("你的大恩大德，我下辈子再报！");  
    }  
}
```

它的加载过程是怎么样的呢？
- 执行 main() 方法（静态方法）就需要先加载 main()方法所在类 HelloLoader
- 加载成功，则进行连接初始化等操作，完成后调用 HelloLoader 类中的静态方法 main()
- 加载失败，则抛出异常

![类加载过程](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212013447.png)
完整的流程图如下：

![类加载流程图](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212025665.png)

### 加载Loading
**加载：**
	1. 通过一个类的全限定名获取定义此类的二进制字节流
	2. 将这个字节类所代表的的静态存储结构转化为方法区的运行时数据结构
	3. <font color="red">在内存中生成代表此类的 java.lang.Class 对象</font>，作为方法区此类的各种数据的访问入口

**加载class文件的方式**
	1.  从本地系统中直接加载
	2.  通过网络获取，典型场景：Web Applet
	3.  从zip压缩包中读取，成为日后jar、war格式的基础
	4.  运行时计算生成，使用最多的是：动态代理技术
	5.  由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见
	6.  从加密文件中获取，典型的防Class文件被反编译的保护措施

### 链接Linking
链接分为3个子阶段：验证（Verify) 、准备（Prepare）、解析（Resolve）
**1. 验证（Verify）**
	- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性
	- 主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证

**举例**
使用 BinaryViewer 软件查看字节码文件，其开头均为 `CAFE BABE` ，如果出现不合法的字节码文件，那么验证将不通过。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212047257.png)

**2. 准备（Prepare）**
	- 为类变量（static变量）分配内存并且设置该类变量的默认初始值，零值
	- 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
	- 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

**举例**
变量a在准备阶段会赋初始值0，在初始化阶段被赋值为1
```java
public class HelloApp {  
    private static int a = 1;//prepare：a = 0 ---> initial : a = 1  
  
  
    public static void main(String[] args) {  
        System.out.println(a);  
    }  
}
```

**3.解析（Resolve）
- **将常量池内的符号引用转化为直接引用的过程**
- 解析操作往往会随着JVM在执行完初始化之后再执行
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等

>符号引用：反编译class文件后可以查看符号引用，下面带#的就是符号引用
>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码
>![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202210212055487.png)

### 初始化Initializing
类的初始化时机
1. 创建类的实例
2. 访问某个类或接口的静态变量，或对该静态变量赋值
3. 调用类的静态方法
4. 反射，比如`Class.forName("HelloWorld")`，HelloWorld.java
5. 初始化一个类的子类
6. Java 虚拟机启动时被标记为启动类的类
7. JDK7 开始提供的动态语言支持：`java.lang.invoke.MethodHandle` 实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则初始化

初始化：
- 初始化阶段就是执行类构造器方法`<clint>()`的过程
- 此方法不需定义，由javac编译器自动收集类中的所有的类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- `<clint<>()` 不同与类的构造器，关联：构造器是虚拟机视角下的`init<>()`
- 若该类存在父类，JVM会保证子类的`<clinit>()` 执行前，父类的`<clint>()`已经执行完成
- 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁

