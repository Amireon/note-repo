# 第5章 堆
## 1.堆的核心概念
### 1.堆与进程
堆针对一个JVM进程来说是唯一的，也就是**一个进程只有一个JVM实例**，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和方法。
但是，**进程包含多个线程，这些线程共享同一堆空间。**

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211071937186.png)

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆内存在JVM启动时刻被创建，其空间大小也就确定了，堆是JVM管理的最大的一块内存空间，并且堆内存的大小是可以调节的。
- 《Java虚拟机规范》中，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，此处还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，**TLAB**）。
- 《Java虚拟机规范》中对java堆的描述是：**所有的对象实例以及数组都应在运行时分配在堆上**（The heap is the run-time data area from which memory for all class instances and arrays is allocated）。从实际角度看，“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）
- 数组和对象可能永远不会存储在栈上（不一定），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
- 在方法结束后，堆中的对象不会马上被移除，只在垃圾收集时才会被移除，
	- 即触发了GC时才会回收，
	- 如果堆中对象马上回收，那么用户线程就会收到影响，因为有`stop the word`
- 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。

```java
public class SimpleHeap {  
    private int id;//属性、成员变量  
  
    public SimpleHeap(int id) {  
        this.id = id;  
    }  
  
    public void show() {  
        System.out.println("My ID is " + id);  
    }  
    public static void main(String[] args) {  
        SimpleHeap sl = new SimpleHeap(1);  
        SimpleHeap s2 = new SimpleHeap(2);  
  
        int[] arr = new int[10];  
  
        Object[] arr1 = new Object[10];  
    }  
}
```

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211152128990.png)


### 2.堆内存细分
1. 现代垃圾收集器大部分基于分代手机理论，堆内存空间细分为：

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211152145058.png)

JDK7及之前堆内存逻辑分为三部分：`新生区+养老区+永居区`
- `新生区`：Young Generation，又分为 Eden 区，Survivor 区
- `养老区`：Old Generation Space，Old/Tenure
- `永久区`：Permanent Space ， Perm

JDK8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间（Meta Space， Meta）

>约定：新生区 <–> 新生代 <–> 年轻代 、 养老区 <–> 老年区 <–> 老年代、 永久区 <–> 永久代

2. 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211152150606.png)

## 2.设置堆内存
### 核心概念
Java堆区用于存储Java对象实例，其大小在JVM启动时设定，可以通过参数”-Xms”和”-Xmx”设置：
- `-Xms`：表示堆区的起始内存，等价于 `-XX:InitialHeapSize`，默认物理电脑内存大小/64
- `-Xmx`：表示堆区的最大内存，等价于 `-XX:MaxHeapSize`，默认物理电脑内存大小/4
 一旦堆区中的内存大小超过`-Xmx`所指定的最大内存时，会抛出OutofMemoryError异常。
 
但是我们通常使-Xms和-Xmx的值相等，原因：
- 假设两者不等，如初始内存小，最大内存大。在运行期间如果堆内存不够用，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。
- 如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM

### 代码实验
运行如下代码：
```java
/**  
 * 1. 设置堆空间大小的参数  
 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小  
 *      -X 是jvm的运行参数  
 *      ms 是memory start  
 * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小  
 *  
 * 2. 默认堆空间的大小  
 *    初始内存大小：物理电脑内存大小 / 64  
 *             最大内存大小：物理电脑内存大小 / 4  
 * 3. 手动设置：-Xms600m -Xmx600m  
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。  
 *  
 * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id  
 *                  方式二：-XX:+PrintGCDetails  
 */  
public class HeapSpaceInitial {  
    public static void main(String[] args) {  
  
        //返回Java虚拟机中的堆内存总量  
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;  
        //返回Java虚拟机试图使用的最大堆内存量  
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;  
  
        System.out.println("-Xms : " + initialMemory + "M");  
        System.out.println("-Xmx : " + maxMemory + "M");  
  
        System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");  
        System.out.println("系统内存大小为：" + maxMemory * 4.0 / 1024 + "G");  
  
        try {  
            Thread.sleep(1000000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

输出结果：
```java
-Xms : 123M  
-Xmx : 1794M  
系统内存大小为：7.6875G  
系统内存大小为：7.0078125G
```

笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些，两个不一样的原因待会再说。

调整一下参数再看：
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072018875.png)

```java
public class HeapSpaceInitial {  
    public static void main(String[] args) {  
  
        //返回Java虚拟机中的堆内存总量  
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;  
        //返回Java虚拟机试图使用的最大堆内存量  
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;  
  
        System.out.println("-Xms : " + initialMemory + "M");  
        System.out.println("-Xmx : " + maxMemory + "M");  
  
  
        try {  
            Thread.sleep(1000000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

输出结果：
```java
-Xms : 575M  
-Xmx : 575M
```

可以看到少了25M空间，原因分析：
**方式一： jps / jstat -gc 进程id**
>`jps`：查看java进程
>`jstat`：查看某进程内存使用情况

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072022820.png)

图中参数含义如下：
- SOC: S0区总共容量  
- S1C: S1区总共容量  
- S0U: S0区使用的量  
- S1U: S1区使用的量  
- EC: 伊甸园区总共容量  
- EU: 伊甸园区使用的量  
- OC: 老年代总共容量  
- OU: 老年代使用的量

计算一番：
（1）25600+25600+153600+409600 = 614400K，614400 /1024 = 600M
（2）25600+153600+409600 = 588800K ，588800 /1024 = 575M
这并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）

**方式二：-XX:+PrintGCDetails**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072025377.png)

## 3.设置OOM
1.设置虚拟机参数：`-Xms600m -Xmx600m`
```java
public class OOMTest {  
    public static void main(String[] args) {  
        ArrayList<Picture> list = new ArrayList<>();  
        while(true){  
            try {  
                Thread.sleep(20);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            list.add(new Picture(new Random().nextInt(1024 * 1024)));  
        }  
    }  
}  
  
class Picture{  
    private byte[] pixels;  
  
    public Picture(int length) {  
        this.pixels = new byte[length];  
    }  
}
```

输出结果：
```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space  
	at com.atguigu.java.Picture.<init>(OOMTest.java:29)  
	at com.atguigu.java.OOMTest.main(OOMTest.java:20)  
  
Process finished with exit code 1
```

2.堆内存变化图
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072028348.png)

原因：大对象导致堆内存溢出
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072028224.png)

## 4.年轻代与老年代
存储在JVM中的Java对象被分为两类：
- 一类是生命周期较短的瞬时对象，创建和消亡都非常迅速
- 另一类对象生命周期非常长，在某些极端情况下还能与JVM的生命周期保持一致

Java堆区进一步细分，可以划分为年轻代（YoungGen）和老年代（oldGen），其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211162023901.png)

下面参数开发中一般不会调整：
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211162027630.png)

 配置新生代与老年代在堆结构的占比    
   - 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3
   - `-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，可以通过
	`-XX:SurvivorRatio`，调整空间比例
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
- 可以使用`-Xmn`设置新生代最大内存大小，但这个参数一般使用默认值就可以了。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072044285.png)

**参数说明：**
 * -Xms600m -Xmx600m  
 *  
 * `-XX:NewRatio `： 设置新生代与老年代的比例。默认值是2.  
 * `-XX:SurvivorRatio `：设置新生代中Eden区与Survivor区的比例。默认值是8  
 * `-XX:-UseAdaptiveSizePolicy` ：关闭自适应的内存分配策略  （暂时用不到）  
 * `-Xmn`：设置新生代的空间的大小。 （一般不设置）   

实验代码：
```java
public class EdenSurvivorTest {  
    public static void main(String[] args) {  
        System.out.println("我只是来打个酱油~");  
        try {  
            Thread.sleep(1000000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
}
```

## 5.图解对象分配过程
为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里
分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是
否会在内存空间中产生内存碎片。

新对象分配内存的具体流程：
1. new 的对象先放在伊甸园区，此区大小有限制。
2. 当伊甸园区空间满时，此时程序又要创建对象，JVM 的垃圾回收器对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象销毁，再加载新的对象到伊甸园区。
3. 将伊甸园区中的剩余对象移动到幸存者0区
4. 如果再次触发垃圾回收，上次幸存的放到幸存者0区的对象，如果没有回收，就会放被到幸存者1区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6.  啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N
7. 养老区相对悠闲，当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理
8. 若养老区执行了Major GC，发现依然无法进行对象的保存，就会产生OOM异常。

### 1.一般情况
我们创建的对象，一般都存放在Eden区，**当Eden区满了后，就会触发GC操作**，一般称为 YGC / Minor GC操作

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211162100324.png)


当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0（Survivor From）区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。
同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1

>下一次再进行GC的时候，
>1.这一次的s0区为空，所以成为下一次GC的S1区
>2.这一次的s1区则成为下一次GC的S0区
>3.也就是说s0区和s1区在互相转换。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211072054208.png)

我们继续进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211162101922.png)

关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。

### 2.特殊情况
对象分配的特殊情况，
1. 如果来了一个新对象，先判断 Eden 区是否放得下
	- 如果 Eden 区放得下，则直接放在 Eden 区
	- 如果 Eden 区放不下，则触发 YGC，执行垃圾回收，再判断是否放得下

2. 将对象放到老年区有两种情况，
	- 如果 Eden 执行了 YGC 还是无法放下该对象，只能说明是超大对象，只能放在老年代
	- 如果老年代也无法放置，则先触发 FullGC，但如果还是放不下，那只能报 OOM

3. 如果 Eden 区满了，将对象向辛存区拷贝时，如果辛存区空间不足，则只能让某些新对象进入老年区

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202211151924083.png)

## 6.GC分类
1. JVM 调优的一个环节就是垃圾回收，我们需要尽量避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World），**而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上**

2. JVM 在进行 GC 时，并非每次都对以上的三个内存区域进行回收，大部分回收都是指新生代。针对 Hotspot 实现，GC 按照回收区域可分为两大类型：部分回收(Partial GC)和整堆回收（FullGC）

3. 部分收集：不完整收集整个Java堆，其中又分为：
	- 新生代收集（Minor GC/Young GC）：只是新生代（Eden，S0，S1）的垃圾收集
	- 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
		- 目前，只有CMS GC会有单独收集老年代的行为。
		- 很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
	- 混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。目前只有G1 GC会有这种行为

4. 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

### 1.Minor GC
**Minor GC 与年轻代GC（Young GC）触发机制完全相同**
1. 当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会主动引发 GC。在Eden区满时，会顺带触发s0区的GC，也就是被动触发GC。每次 Minor GC 都会清理年轻代的内存
2. Java对象的生命周期都比较短，所有 Minor GC 触发非常频繁，回收速度一般也比较快
3. Minor GC 会引发STW，暂定用户的其他线程，等待垃圾回收结束，用户线程才会恢复运行


### 2.Major GC
**老年代GC(Major GC/Full GC)触发机制**
1. 指发生在老年代的GC，对象从老年代消失时，就称Major GC或Full GC发生了
2. 出现了Major GC，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。即在老年代空间不足时，会先尝试触发Minor GC，若空间仍然不足，则触发Major GC
3. Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
4. 若Major GC后，内存空间仍然不足，报OOM


### 3.Full GC
> 后面详解。Full GC是开发或调优中应尽量避免的

触发 Full GC 的情况有以下五种：
- 调用 `System.gc()`，系统建议执行 Full GC， 但是不一定真的执行
- 老年代空间不足
- 方法区空间不足
- 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
- 由Eden区，survivor spcae0(From Space)区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### 4.GC日志分析
```java
/**  
 * 测试MinorGC 、 MajorGC、FullGC  
 * -Xms9m -Xmx9m -XX:+PrintGCDetails  
 * @author shkstart  shkstart@126.com  
 * @create 2020  14:19  
 */  
public class GCTest {  
    public static void main(String[] args) {  
        int i = 0;  
        try {  
            List<String> list = new ArrayList<>();  
            String a = "atguigu.com";  
            while (true) {  
                list.add(a);  
                a = a + a;  
                i++;  
            }  
  
        } catch (Throwable t) {  
            t.printStackTrace();  
            System.out.println("遍历次数为：" + i);  
        }  
    }  
}
```

输出内容
```
[GC (Allocation Failure) [PSYoungGen: 2037K->504K(2560K)] 2037K->728K(9728K), 0.0455865 secs] [Times: user=0.00 sys=0.00, real=0.06 secs]   
[GC (Allocation Failure) [PSYoungGen: 2246K->496K(2560K)] 2470K->1506K(9728K), 0.0009094 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   
[GC (Allocation Failure) [PSYoungGen: 2294K->488K(2560K)] 3305K->2210K(9728K), 0.0009568 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   
[GC (Allocation Failure) [PSYoungGen: 1231K->488K(2560K)] 7177K->6434K(9728K), 0.0005594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   
[GC (Allocation Failure) [PSYoungGen: 488K->472K(2560K)] 6434K->6418K(9728K), 0.0005890 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   
[Full GC (Allocation Failure) [PSYoungGen: 472K->0K(2560K)] [ParOldGen: 5946K->4944K(7168K)] 6418K->4944K(9728K), [Metaspace: 3492K->3492K(1056768K)], 0.0045270 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]   
[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 4944K->4944K(8704K), 0.0004954 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]   
[Full GC (Allocation Failure) java.lang.OutOfMemoryError: Java heap space  
	at java.util.Arrays.copyOf(Arrays.java:3332)  
	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)  
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)  
	at java.lang.StringBuilder.append(StringBuilder.java:136)  
	at com.atguigu.java1.GCTest.main(GCTest.java:20)  
[PSYoungGen: 0K->0K(1536K)] [ParOldGen: 4944K->4877K(7168K)] 4944K->4877K(8704K), [Metaspace: 3492K->3492K(1056768K)], 0.0076061 secs] [Times: user=0.00 sys=0.02, real=0.01 secs]   
遍历次数为：16  
Heap  
 PSYoungGen      total 1536K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  
  eden space 1024K, 5% used [0x00000000ffd00000,0x00000000ffd0f058,0x00000000ffe00000)  
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)  
 ParOldGen       total 7168K, used 4877K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  
  object space 7168K, 68% used [0x00000000ff600000,0x00000000ffac3408,0x00000000ffd00000)  
 Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K  
  class space    used 391K, capacity 394K, committed 512K, reserved 1048576K
```

- [PSYoungGen: 2037K->504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K  
- 2037K->728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K

## 7.堆空间分代思想
**Q**: 为什么要把Java堆分代？不分代就不能正常工作了吗？
**A1**: 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
- 新生代：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。
- 老年代：存放新生代中经历多次GC仍然存活的对象。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301271528709.png)

**A2**: 不分代完全可以，分代的唯一理由是优化GC性能
- 如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）
- 很多对象都是朝生夕死的，如果分代，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301271528569.png)


## 8.对象内存分配策略
1. 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。
2. 对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代
3. 对象晋升老年代的年龄阀值，可以通过选项 `-XX:MaxTenuringThreshold` 来设置

**针对不同年龄段的对象分配原则如下所示：**

1. **优先分配到Eden**：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢
2. **大对象直接分配到老年代**：尽量避免程序中出现过多的大对象
3. **长期存活的对象分配到老年代**
4. **动态对象年龄判断**：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
5. **空间分配担保**： -XX:HandlePromotionFailure 。

## 9.对象分配过程:TLAB
Q: 为什么有TLAB(Thread Local Allocation Buffer)?
1. 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
2. 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
3. 为避免多个线程操作同一地址，需要使用**加锁等机制**，进而影响分配速度。


Q: 什么是TLAB?
TLAB（Thread Local Allocation Buffer）
1. 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，**JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内**。
2. 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配策略**。
3.基本所有OpenJDK衍生的JVM都提供了TLAB的设计。
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301271813763.png)

- 每个线程都有一个TLAB空间
- 当一个线程的TLAB存满时，可以使用公共区域（蓝色）的

**TLAB再说明**
1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。 
2. 在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。 
3. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。 
4. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制确保数据操作的原子性**，从而直接在Eden空间中分配内存。

TLAB分配过程

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301271815461.png)


## 10.堆空间的参数设置
### 1.堆空间常用的jvm参数
> **官方文档**：[https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)
> 具体查看某个参数的指令： 
> - jps：查看当前运行中的进程  
> - jinfo -flag 参数 进程id 

- `-XX:+PrintFlagsInitial`: 查看所有的参数的默认初始值  
- `-XX:+PrintFlagsFinal`: 查看所有的参数的最终值（可能会存在修改，不再是初始值）   
- `-Xms`：初始堆空间内存 （默认为物理内存的1/64）  
- `-Xmx`：最大堆空间内存（默认为物理内存的1/4）  
- `-Xmn`：设置新生代的大小。(初始值及最大值)  
- `-XX:NewRatio`：配置新生代与老年代在堆结构的占比  
- `-XX:SurvivorRatio`：设置新生代中Eden和S0/S1空间的比例  
- `-XX:MaxTenuringThreshold`：设置新生代垃圾的最大年龄  
- `-XX:+PrintGCDetails`：输出详细的GC处理日志  
- `-XX:+PrintGC` 或 `-verbose:gc`: 打印GC简要信息
- `-XX:HandlePromotionFailure`: 是否设置空间分配担保  

### 2.空间分配担保
在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
-  如果大于，则此次Minor GC是安全的
-  如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允担保失败。
    - 如果`HandlePromotionFailure=true`，那么会继续检查**老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
        - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
        - 如果小于，则进行一次Full GC。
    - 如果`HandlePromotionFailure=false`，则进行一次Full GC。

**历史版本**
1. 在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。
2. JDK6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC**，否则将进行Full GC。即`HandlePromotionFailure=true`

