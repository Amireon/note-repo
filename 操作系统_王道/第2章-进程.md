## 2.1 进程
### 1.进程概述

引入多道程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了进程进程实体的概念

操作内存中同时放入多道程序，各个程序的代码、运算数据存放的位置不同。操作系统要怎么才能找到各程序的存放位置呢？

系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码放位置）

**程序段、数据段、PCB三部分组成了进程实体（进程映像）**。一般情况下，我们把进程实体就简称为进程

例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

**PCB是进程存在的唯一标志！**

**1.进程的组成**
`进程 = PCB + 程序段 + 数据段`
- PCB：进程的管理者（操作系统）所需的数据都在PCB中
- 程序段+数据段：程序本身运行所需的数据

PCB的存储内容
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131645632.png)

**2.进程的组织**
- `链接方式`：按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针
- `索引方式`：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针

**3.进程的特征**
- `动态性`：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征
- `并发性`：内存中有多个进程实体，各进程可并发执行
- `独立性`：进程是能独立运行、独立获得资源、独立接受调度的基本单位
- `异步性`：各进程按各自独立的、不可预知的速度向前推进；操作系统要提供“进程同步机制”来解决异步问题
- `结构性`：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131657055.png)

### 2.进程的状态与转换
#### 1.进程的状态
进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态

**1.进程的三种基本状态**
- `运行态(Running)`：占有CPU，并在CPU上运行
> 单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进桂处于运行态
- `就绪态(Ready)`：已经具备运行条件，但由于没有空闲CPU，所以暂时不能运行
> 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
- `阻塞态(Waiting/Blocked)`：又称等待态，因等待某一事件暂时不能运行
> 如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务

#### 2.进程状态的转换
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710658.png)

**小结**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301131710911.png)

### 3.进程控制
`进程控制`：实现进程状态的转换
进程控制使用**原语实现**
- 原语用关/开中断实现
- 原语是一种特殊的程序
- 原语的执行必须一气呵成，不可中断
- 相关原语：创建、终止、阻塞、唤醒、切换；阻塞和唤醒成对出现

学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：
1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境
	a.所有的进程控制原语一定都会修改进程状态标志
	b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境
	c.某进程开始运行前必然要恢复期运行环境
1. 将PCB插入合适的队列
2. 分配/回收资源

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141228084.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141229710.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230611.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141230688.png)

### 4.进程通信
- 进程通信就是指进程之间的信息交换。
- 进程是分配系统资源的单位（包括内存地址空间），因此**各进程拥有的内存地址空间相互独立**
- 一个进程不能直接访问另一个进程的地址空间
但是进程之间的信息交换又是必须实现的为了保证进程间的安全通信，操作系统提供了一些方法

进程通信的三种方式：
- `共享存储`：基于数据结构的共享，基于存储区的共享
- `消息传递`：直接通信方式，间接通信方式
- `管道通信`：
	- 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道；
	- 各进程互斥地访问管道；
	- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read(系统调用将被阻塞
	- 如果管道没写满，则不允许读；如果管道没读空，则不允许写
	- 读进程只能有一个

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141245238.png)



## 2.2 线程
### 1.线程概述
- 可以把线程理解为“轻量级进程”。
- 线程是一个基本的CPU执行单元也是程序执行流的最小单位
- 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件
- 引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。

**1.引入线程带来的变化**
- `资源分配、调度`：进程机制中，进程是资源分配的基本单位；引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- `并发性`: 传统进程机制中，只能进程间并发; 引入线程后，各线程间也能并发，提升了并发度
- `系统开销`：传统的进程间并发,需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

**2.线程的属性**
- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPu
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小


**2.线程的实现方式**
**用户级线程(User-Level Thread,ULT)**
- 用户级线程由应用程序通过线程库实现
- 所有的线程管理工作都由应用程序负责（包括线程切换）
- 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
- 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明
- 可以这样理解，“用户级线程”就是“从用户视角看能看到的线程

**内核级线程(Kernel-Level Thread, KLT)**
- 内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
- 可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程

操作系统只看见内核级线程，因此只有内核级线程才是处理机分配的单位

**3.多线程模型**
多对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141319114.png)

一对一
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141320339.png)

多对多
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141321977.png)


![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141322947.png)


### 2.处理机调度
处理机调度：按照某种算法选择一个进程将处理机分配给它
三层调度的联系、对比
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141359904.png)


### 3.进程调度
进程调度(低级调度)：从就绪队列中选择一个进程为其分配处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141406871.png)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141414571.png)

### 4.调度算法的评价指标

| 指标         | 含义                                                   | 公式                                           |
| ------------ | ------------------------------------------------------ | ---------------------------------------------- |
| CPU利用率    | CPU忙碌的时间占总时间的比例                            | CPU利用率 = CPU忙碌的时间 / 总时间             |
| 系统吞吐量   | 单位时间内完成作业的总数                               | 系统吞吐量 = 完成的作业总数 / 总时间           |
| 周转时间     | 指从作业提交给系统开始，到作业完成为止的这段时间间隔。 | 作业周转时间 = 作业完成时间 - 作业提交时间     |
| 带权周转时间 | 考虑进程实际运行时间                                   | 带权周转时间 = 作业周转时间 / 作业实际运行时间 |
| 等待时间     | 指进程/作业处于等待处理机状态时间之和                  |                                                |
| 响应时间     | 从用户提交请求到首次产生响应所用的时间                 |                                                |

**周转时间**包括四个部分：
- 作业在外存后备队列上等待作业调度（高级调度）的时间
- 进程在就绪队列上等待进程调度（低级调度）的时间
- 进程在CPU上执行的时间
- 进程等待I/0操作完成的时间
后三项在一个作业的整个处理过程中，可能发生多次

**带权周转时间**：
- 对于周转时间相同的两个作业，实际运行时间长的作业在相司时间内被服务的时间更多，带权周转时间更小，用户满意度更高
- 对于实际运行时间相司的两个作业，周转时间短的带权周转时间更小，用户满意度更高
- 带权周转时间必然 ≥ 1
- 带权周转时间与周转时间都是越小越好

**等待时间**：
- 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的、所以不计入等待时间。
- 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- 一个作业总共需要被CPU服务多久，被I/0设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141432245.png)

### 5.调度算法分析
先来先服务(FCFS, First Come First Serve)

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141629766.png)

短作业优先(SJF, Shortest Job First)
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141701505.png)

高响应比优先(HRRN, Highest Response Ratio Next)
非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141706851.png)

| 算法    | 是否抢占                                       | 优点                         | 缺点                                   | 考虑点             | 是否饥饿 |
| ------- | ---------------------------------------------- | ---------------------------- | -------------------------------------- | ------------------ | -------- |
| FSFC    | 非抢占                                         | 公平；实现简单               | 对短作业不利                           | 等待时间           | 不会     |
| SJF/SPF | 默认非抢占式，抢占式的最短剩余时间优先算法SRTN | “最短”平均等待时间/周转时间  | 对长作业不利；难以完成真正的短作业优先 | 运行时间           | 会       |
| HRRN    | 非抢占式                                       | 上述两种算法的权衡，综合考虑 |                                        | 等待时间和运行时间 | 不会         |

>- 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，对于用户来说，交互性很糟糕。
>- 因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。
>- 而适合用于交互式系统的调度算法将在下个小节介绍!…

### 6.调度算法:交互式系统
时间片轮转调度算法、优先级调度算法、多级反馈队列调度算法

时间片轮转算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141733685.png)

优先级调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141749370.png)

多级反馈队列调度算法
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141755356.png)

| 算法         | 是否抢占 | 优点                       | 缺点                         | 是否饥饿 | 补充                                  |     |
| ------------ | -------- | -------------------------- | ---------------------------- | -------- | ------------------------------------- | --- |
| 时间轮转     | 抢占式   | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级 | 不会     | 时间片太大或太小的影响                |     |
| 优先级调度   | 都有     | 区分优先级，适用于实时系统 | 可能导致饥饿                 | 会       | 动态/静态优先级，个进程如何设置优先级 |     |
| 多级反馈队列 | 抢占式   | 平衡                       | 可能饥饿                     | 会       |                                       |     |

>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
>而这几种算法恰好也能较好地满足交互式系统的需求,比如UNIX使用的就是多级反馈队列调度算法


## 2.3 进程同步与互斥
**1.什么是进程同步**
读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的如何解决这种异步问题，就是“进程同步”所讨论的内容。

**同步亦称直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

**2.什么是进程互斥**
我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥地进行。

**互斥，亦称间接制约关系**。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后另一个进程才能去访问临界资源

对临界资源的互斥访问，可以在逻辑上分为如下四部分：

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301141812090.png)

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则
- `空闲让进`: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区:
- `忙则等待`: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待
- `有限等待`: 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
- `让权等待`: 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

### 1.进程互斥的软件实现算法
单标志法、双标志先检查、双标志后检查、Peterson算法

> - 理解各个算法的思想、原理
> - 结合“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区的行为
> - 分析各算法存在的缺陷

**1.单标志法**
- 算法思想：两个进程在访问完临界区后会把使用临界区的权限交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予
- 该算法可以实现**同一时刻最多只允许一个进程访问临界区**
- 问题：如果初始进程长时间不访问临界区，那么临界区将处于空闲状态，违背“空闲让进”原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150941438.png)

- turn 的初值为0，那么刚开始时只允许 P0 进入临界区（P1会被卡在 while 循环，直至 P1 的时间片用完，调度 P0 上处理机运行）
- P0 使用完临界区后将 turn 的值更改为1，此后 P1 才能使用临界区

 **2.双标志先检查法**
 - 算法思想：设置一个布尔型数组`flag[]`，数组中各个元素用来标记各进程想进入临界区的意愿，比如`flag[0] = ture`意味着0号进程PO现在想要进入临界区。
 - 每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为true，之后开始访问临界区
 - 问题：并发性，进程可能同时访问临界区，违背“忙则等待”原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150951045.png)

若按照 152..48 的顺序执行，PO 和 P1 将会同时访问临界区。
原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。

**3.双标志后检查法**
- 算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查’的方法，来避免上述问题
- 问题：并发性，死锁，违背“空闲让进”和“有限等待”原则，让各进程都长期无法访问临界区

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301150956202.png)

若按照 152..48 的顺序执行，PO 和 P1 都将会无法访问临界区。
因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象

**4.Peterson算法**
- 算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到，如果双方都争着想进入临界区，那可以让进程主动让对方先使用临界区
- 问题：Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、则等待、有限等待三个原则，但是依然未遵循让权等待的原则

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151000794.png)

- 两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。
- 我们可以推理验证在 Peterson 算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况: 123678... 或 1623 ...

实心进程互斥的软件方法的四种算法的比较
| 算法           | 思想                                                        | 问题                                    |
| -------------- | ----------------------------------------------------------- | --------------------------------------- |
| 单标志法       | 在进入区只"检查"，不"上锁";在退出区把临界区使用权转交       | 不遵循"空闲让进"原则                    |
| 双标志先监察法 | 在进入区先"检查"后"上锁", 退出区"解锁"                      | 不遵循"忙则等待"原则                    |
| 双标志后检查法 | 在进入区先"上锁"后"检查", 退出区"解锁"                      | 不遵循"空闲让进,有限等待"原则，可能饥饿 |
| Peterson 算法  | 在进入区"主动争取-主动谦让-检查对方是否想使用,己方是否谦让" | 不遵循"让权等待"原则，会导致"忙等"                                        |

### 2.进程互斥的硬件实现算法
> 中断屏蔽方法、TestAndSet(TS指令/TSL指令)，Swap指令(XCHG指令)

**1.中断屏蔽方法**
- 思路：利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况
- 优点：简单高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151015112.png)

**2.TestAndSet指令**
- 简称 TS指令，也有称 TestAndSetLock指令，或 TSL指令
- 思路：TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
- 相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作
- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”
 
以下是用C语言描述的逻辑
```c
//布尔型共享变量 lock 表示当前临界区是否被加锁
//true 表示已加锁,false 表示未加锁
bool TestAndSet（bool *lock){
	bool oLd;
	old = *lock； //old 用来存放 lock 原来的值
	*lock = true； //无论之前是否已加锁，都将 lock 设为 true
	return oLd；  //返回 lock 原来的值
}
```

以下是使用 TSL指令 实现互斥的算法逻辑
```c
while（TestAndSet(&lock)); //"上锁"并“检查
临界区代码段...
lock = false;               //“解锁”
剩余区代码段...
```

- 若 lock 初始值是false，则 TSL返回的 old 值为false，while循环条件不满足，直接跳过循环，进入临界区。
- 若 lock 初始值是true，则执行 TSL 后 old 值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”

**3.Swap指令**
- 有的地方也叫Exchange 指令，或简称 XCHG指令。
- Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
 
 
以下是用C语言描述的逻辑
```c
//Swap指令的作用是交换两个变量的值
Swap(bool *a*, bool *b){
	bool temp:
	temp = *a；
	*a = *b;
	*b = temp;
}
```

以下用Swap指令实现互斥的算法逻辑
```c
//lock泰示当前临界区是否发加
bool old = true;
while(old = true)
	Swap(&Lock, &old);
临界区代码段...
lock = false;
剩余区代码段...
```

逻辑上来看Swap和 TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old变量上），再将上锁标记lock设置为 true，最后检查 old，如果 old为 false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301151046506.png)


### 3.信号量机制
用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。
信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量













