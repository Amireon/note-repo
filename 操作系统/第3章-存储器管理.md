## 3.1 内存概述
内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理

**Q：如何区分各个程序的数据？**
给内存的存储单元编址
- 内存地址从O开始，每个地址对应一个存储单元
- 按字节编址，则每个存储单元的大小为1字节
- 按字编址，如字长为16位的计算机，则每个存储单元大小为1字，每个字的大小为16bit


### 1.内存管理
操作系统作为系统资源的管理者，也要对内存进行管理，那么应该做什么呢？
- 内存空间的分配与回收
- 从逻辑上对内存空间进行扩充
- 提供地址转换功能，负责程序程序的逻辑地址与物理地址的转换
- 内存保护，保证各进程在各自存储空间内互不干扰

**内存保护的两种方式**
1. 设置上下限寄存器
2. 重定位寄存器: 基址寄存器和界地址寄存器(限长寄存器)，越界检查，重定位寄存器中存放进程的起始物理地址，界地址寄存器中存放进程的最大逻辑地址


### 2.覆盖与交换
内存空间的扩充: 覆盖技术、交换技术、虚拟存储技术

**1.覆盖技术**
- 思想：将程序分为多个段（多个模块）常用的段常驻内存，不常用的段在需要时调入内存
- 内存中分为一个“固定区”和若干个“覆盖区”
- 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）
- 不常用的段放在“覆盖区”，需要用到时调入内存用不到时调出内存
- 缺点：必须由程序员声明覆盖结构，操作系统完成自动宥盖。缺点：对用户不透明，增加了用户编程负担，覆盖技术只用于早期的操作系统中，现在已成为历史

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161519587.png)

**2.交换技术**
交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）
中级调度(内存调度): 决定将哪个处于挂起状态的进程重新调入内存

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161521877.png)

- 暂时换出外存等待的进程状态为挂起状态（挂起态，Suspend
- 挂起态又可以进一步细分为就绪桂起、阻塞挂起两种状态

**Question**
1. 被换出的进程应该保存在外存的什么位置？
2. 应该什么时候交换？
3. 应该换出哪些进程？

1. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。
	- 文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式
	- 对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。
	- 由于对换的速度直按影响到系统的整体速度，因此对换区空间的管理主要追求换人换出速度，因此通常对换区采用用连续分配万式。
	- 总之，对换区的I/O速度比文件区的更快
1. 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程如果缺页率明显下降，就可以暂停换出
2. 可优先换出阻塞进程；可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间. PCB常驻内存


### 3.连续分配管理方式
- 连续分配: 为用户进程分配的内存必须是一个连续的内存空间
- 三种方式: 单一连续分配、固定分区分配、动态分区分配

#### 1.单一连续分配
在单一连续分配方式中，内存被分为系统区和用户区
- 系统区: 通常位于内存的低地址部分，用于存放操作系统相关数据
- 用户区: 用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。
- 优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护
- 缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。分配给果进杜的内存X域中如果有些部分没有月上，就是“内部碎片

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161538783.png)

#### 2.固定分区分配
将用户空间划分为若干个顶大小的分区，在每个分区中只装入一道作业
- 分区大小相等: 缺乏灵活性，适用于用一台计算机控制多个相同对象的场合
- 分区大小不等: 增加了灵活性，可以满足不同大小的进程需求，根据常在系统运行的作业大小情况进行划分

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161542595.png)

- 操作系统需要建立一个数据结构-分区说明表，来实现各个分区的分配与回收。
- 每个表项对应一个分区，通常按照分区大小排列
- 每个表项包括对应分区的大小、起始地址、状态

- 优点：实现简单，无外部碎片
- 缺点：当用户程序太大时，可能所有的分区都不能满足需求，只能采取覆盖技术；产生内部碎片，内存利用率低

#### 3.动态分区分配
动态分区分配：又称可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

动态分区分配没有内部碎片，但是有外部碎片，可以通过紧凑（拼凑，Compaction）技术来解决外部碎片
- 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上
- 外部碎片，是指内存中的某些空闲分区由于太小而难以利用


**Q1.系统用什么样的数据结构记录内存的使用情况？**
- 空闲分区表: 每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
- 空闲分区链: 每个分区的起始部分和末尾部分分别为前向指针和后向指针。起始部分处还可记录分区大小信息

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161626947.png)

**Q2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？**
把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空困分区链）中选出一个分区配给该作业。分配算法算法对系统性能有很大的影响

### 4.动态分区分配算法
动态分区分配算法：当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

**1.首次适应算法**
- 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
- 如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

**2.最佳适应算法**
- 算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空困区。
- 如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
- 缺点：每次都选最小的分区进行分配，会产生大量外部碎片

**3.最坏适应算法**
又称最大适应算法（Largest Fit）
- 算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空困区，这样分配后剩余的空困区就不会太小，更方便使用。如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区
- 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被讯速用完。如果之后有“大讲程”到达，就没有内存分区可用了

**4.邻近适应算法**
- 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
- 如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
- 首次适应算法每次都要从头合找，每次都需要检索低地址的小分X但是这种规则也决定了当低地址部分有更小的分区可以满足需求时会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下米（最佳适应算法的优点
- 邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161723274.png)

### 5.基本分页存储管理
- 连续分配：为用户进程分配的必须是一个连续的内存空间
- 非连续分配：为用户进程分配的可以是一些分散的内存空间
- 基本分页存储管理、基本分段存储管理、段页式存储管理

**基本分页存储管理**
思想: 把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分
- 将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。
- 将用户进程的地址空间也分为与页框大小相等的一个个区域称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始.(注：进程的最后一个页面可能没有一个页框那么大。因此页框不能太大，否则可能产生过大的内部碎片
- 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。
- 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161801093.png)

**Q1: 将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？**
1. 要算出逻辑地址对应的页号
2. 要知道该页号对应页面在内存中的起始地址
3. 要算出逻辑地址医页面内的“偏移量”
4. 物理地址=页面始址+页内偏移量

计算公式:
- `页号 = 逻辑地址 / 页面长度`, 取整数部分
- `页内偏移量 = 逻辑地址 % 页面长度`
- 页面在内存中的起始位置: 操作系统需要用某种数据结构记录进程各个页面的起始位置


如何实现地址的转换
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161951837.png)


**逻辑地址结构**
分页存储管理的逻辑地址结构如下所示:
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161951865.png)

- 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中O~11位为“页内偏移量”，或称“页内地址”；12~31位为“页号”。
- 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是 $2^k$ 个内存单元
- 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有 $2^M$ 个页面上

**分页存储管理中，如何实现地址转换:**
1. 要算出逻辑地址对应的页号
2. 要知道该页号对应页面在内存中的起始地址
3. 要算出逻辑地址在页面内的“偏移量”
4. 物理地址=页面始址+页内偏移量

注：如果题日中是用十进制数表示逻辑地址，则
- 页号=逻辑地址 页面长度（取除法的整数部分
- 页内偏移量=逻辑地址 %页面长度（取除法的余数部分

**页表**
为了知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表
- 一个进程对应一张页表
- 进程的每一页对应一个页表项
- 每个页表项由“页号”和“块号”组成
- 页表记录进程页面和实际存放的内存块之间的对应关系
- M号内存块的起始地址就是 M * 内存块大小

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301161959534.png)

### 6.基本地址变换机构
基本地址变换机构是基本分页存储管理中用于实现**逻辑地址到物理地址转换**的一组**硬件**机构
- 通常会在系统中设置一个页表寄存器（PTR), 存放页表在内存中的起始地址F和页表长度M
- 进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，
- 当进程被调度时，操作系统内核会把它们放到页表寄存器中
- 页面大小是2的整数幂

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。大比，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

**如何计算逻辑地址A到物理地址E**

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301162020041.png)

**例1**：若页面大小L为1K字节，页号2对应的内存块号 b=8, 将逻辑地址A = 2500转换为物理地址E。
(等价描述L: 某系统按字节寻址，逻辑地址结构中，页内偏移量为10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E)
1. 计算页号P=A/L=2500/1024=2, 页内偏移量W=A%L=2500%1024=452
2. 根据题目，页号2没有越界，其存放的内存块号为8
3. 物理地址E=b * L + W = 8 * 1024 + 425 = 8644

每个页表项的长度是相同的，页号是“隐含”的

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301162029160.png)

### 7.具有快表的地址变换机构
具有快表的地址变换机构是基本地址变换机构的改进版本

**局部性原理**
- `时间局部性`：如果执行了程序中的某条指令，那么不久后这条指令很有可能冉次执行；如果某个数据被访问过，不久之后该数据很可能冉次被访问。（因为程序中存在大量的循环）
- `空间局部性`：一旦程序访问了某个存储单元，其附近的存储单元也很有可能被访问。因为很多数据在内存中都是连续存放的

上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢？


## 3.2 虚拟内存
**传统管理方式的特征、缺点**
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171500728.png)

- `一次性`：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：1作业很大时，不能全部装入内存，导致大作业无法运行；当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。
- `驻留性`：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

**虚拟内存的定义**
- 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存就可以让程序开始执行。
- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将听需信息从外存调入内存，然后继续执行程序。
- 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存
- 在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存，而实际的物理内存大小没有改变，只是在逻辑上进行了扩充

易混知识点:
- 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的
- 虚拟内存的实际容量= min(内存和外存容量之和，CPU寻址范围)

> 如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB
> 则虚拟内存的最大容量为232 B = 4GB
> 虚拟内存的实际容量= min(232B, 512MB+2GB) = 2GB+512MB

**虚拟内存的特征**
- `多次性`：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
- `对换性`：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- `虚拟性`：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

**如何是吸纳虚拟内存**
虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，将很不方便，虚拟内存的实现需要建立在离散分配的内存管理方式基础上，

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171555715.png)

### 1.请求分页管理方式
请求分页存储管理与基本分页存储管理的主要区别:
- 在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需数据从外存调入内存，然后继续执行程序
- 若内存空间不足，操作系统负责将内存中暂时不用的数据换出外存

**1.页表机制**
- 与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道在外存中存放的位置。
- 当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定换出哪个页面: 有的页面没有被修改过，无需浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171615739.png)

**2.缺页中断机构**
在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，操作系统的缺页中断处理程序处理中断。
此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列
- 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。
- 如果内仔中没有空困块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

- 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，属于内中断
- 一条指令执行期间，可能产生多次缺页中断。（如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171620790.png)

**3.地址变换机构**
请求分页存储管理与基本分页存储管理的新增步骤：
- 请求调页：查到页表项时判断
- 页面置换：需要调入页面，但没有空闲内存块时进行
- 需要修改请求页表中新增的表项

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171624008.png)


### 2.页面置换算法
- 最佳置换算法(OPT)，
- 先进先出置换算法(FIFO)，
- 最近最久未使用算法(LRU)，
- 时钟置换算法(CLOCK)，
- 改进型的时钟置换算法

**1.最佳置换算法**
- 最佳置换算法(OPT，Optimal): 每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
- 可以保证最低的缺页率，但操作系统无法预判页面访问序列, 因此最佳置换算法是无法实现的

例：系统为某进程分配了三个内存块，并考虑到有一下页面号引用串（会依次访问这些页面): 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1
![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171700950.png)

**2.先进先出置换算法**
- 先进先出置换算法(FIFO): 每次选择淘汰的页面是最早进入内存的页面
- 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头贝面即可
- 队列的最大长度取决于系统为进程分配了多少个内存块
- 只有先进先出置换算法会产生Belady异常：当为进程分配的物理块数增大时，缺页次数反而增加
- FIFO实现简单，当不适应进程实际运行规律，算法性能差

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171704572.png)

**3.最近最久未使用置换算法**
- 最近最久未使用置换算法(LRU，least recently used): 每次淘汰的页面是最近最久未使用的页面
- 实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t
- 当需要淘汰一个贞面时，选择现有页面中t值最大的，即最近最久未使用的页面
- 评价: 性能优秀，当需要专门的硬件支持，实现困难，开销大

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171710929.png)

淘汰页面时，可以逆向检查此时在内存中的几个页面号，最后一个出现的页号就是要淘汰的页面

**4.时钟置换算法**
- 最佳置换算法性能最好，但无法实现；
- 先进先出置换算法实现简单，但算法性能差；
- 最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是需要专门的硬件支持，算法开销大
- 时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，NotRecently Used)

简单CLOCK算法实现：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。
- 当某页被访问时，将访问位置为1。
- 当需要淘汰一个页面时，检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面。若第一轮扫描中所有页面都为1，在将这些页面的访问均置为0后，进行第二轮扫描
- 第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171717520.png)

**5.改进型的时钟置换算法**
简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。
- 算法思想: 除了考虑页面最近有没有被访问过，还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有被修改过的页面，减少I/0操作。
- 添加修改位：修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过
- 用 (访问位，修改位) 的形式表示各页面状态。如（1，1）表示一个页面近期被访问且被修过。

**算法规则**：将所有可能被置换的页面排成一个循环队列
- 第一轮：从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位
- 第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0
- 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位
- 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。

第二轮扫描已将所有帧的访向位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进的CLOCK置换算法选择一个淘汰页面最多进行四轮扫描

### 3.页面分配策略
- `驻留集`：指请求分页存储管理中给进程分配的物理块的集合
在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小
若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少
驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小

- `固定分配`：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变, 即驻留集大小不变
- `可变分配`：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少,即驻留集大小可变

- `局部置换`：发生缺页时只能选进程自己的物理块进行置换
- `全局置换`：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171741823.png)

`固定分配局部置换`：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）

`可变分配全局置换`：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若己无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加

`可变分配局部置换`：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

`可变分配全局置换`：只要缺页就给分配新物理块

`可变分配局部置换`：要根据发生缺页的频率来动态地增加或减少进程的物理块

**1.何时调入页面**
`预调页策略`：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入(运行前调入), 由程序员指出应该先调入哪些部分。

`请求调页策略`：进程在运行期间发现缺页时才将所缺页面调入内存(运行时调入)。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。

**2.从何处调入页面**
1.系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前需将进程相关的数据从文件区复制到对换区

2.系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前需将进程相关的数据从文件区复制到对换区

3.UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换X，下次需要时从对换区调入

**3.抖动(颠簸)现象**
- 定义: 刚换出的页面马上又要换入内存，刚换入的页面马上又要换出外存，频繁的页面调度行为
- 产生原因: 进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）

为进程分配的物理块太少，会使进程发牛科动现象。为进程分的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率.
为了研究为应该为每个进程分配多少个物理块，Denning提出了进程"工作集”的概念
`工作集`：指在某段时间间隔里，进程实际访问页面的集合。
`驻留集`：指请求分页存储管理中给进程分配的内存块的集合

操作系统会根据窗口尺寸计算工作集

![](https://ypic.oss-cn-hangzhou.aliyuncs.com/202301171813853.png)

工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要
一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页

>拓展：基于局部性原理可知，进程在一段时间内访问的贝面与不久之后会访问的页面是有相关性的
 可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法一一选择一个不在工作集中的页面进行 淘汰


